(function () {
    if (window.ptk_recorder || typeof browser === typeof undefined) return

    const LeftButton = 0
    const MiddleButton = 1
    const RightButton = 2
    const UnknownButton = 3

    const EventTypes = {
        Navigate: 0, Click: 1, KeyPress: 2, Tab: 3, Change: 4, MouseDown: 5, MouseUp: 6, Paste: 7, Delay: 25
    }

    var isIframe = false
    try {
        isIframe = window.self !== window.top
    } catch (e) {
        isIframe = true
    }

    var frameIndex = -1
    if (isIframe) {
        let currentWindow = window
        let currentParentWindow
        while (currentWindow !== window.top) {
            currentParentWindow = currentWindow.parent
            for (let idx = 0; idx < currentParentWindow.frames.length; idx++)
                if (currentParentWindow.frames[idx] === currentWindow) {
                    frameIndex = idx
                    currentWindow = currentParentWindow
                    break
                }
        }
    }


    class ptk_event {
        constructor(e) {
            this.event = (e) ? e : window.event
            let t = this.target()
            this.props = {
                elementType: t.type, id: t.id, name: e.name,
                action: t.action, method: t.method, href: t.href, tagName: t.tagName,
                value: t.value != undefined ? t.value : t.innerText, checked: t.checked,
                form: t.form ? { id: t.form.id, name: t.form.name } : undefined,
                src: t.src, title: t.title
            }

            this.frameIndex = frameIndex
            this.eventStart = (new Date()).getTime()

            let path = e.path ? e.path : e.composedPath()
            this.xpath = this.getElementXPath(e, path);
            this.fullxpath = this.getElementFullXPath(e, path);
            this.csspath = this.getElementCssPath(e, path);
            this.fullcsspath = this.getElementFullCssPath(e, path);
        }

        stopPropagation() {
            if (this.event.stopPropagation)
                this.event.stopPropagation()
        }

        preventDefault() {
            if (this.event.preventDefault)
                this.event.preventDefault()
        }


        button() {
            if (this.event.button) {
                if (this.event.button == 2) {
                    return RightButton
                }
                return LeftButton;
            } else if (this.event.which) {
                if (this.event.which > 1) {
                    return RightButton
                }
                return LeftButton
            }
            return UnknownButton
        }

        target() {
            var t = (this.event.target) ? this.event.target : this.event.srcElement
            if (t && t.nodeType == 3)
                return t.parentNode
            return t
        }

        keycode() {
            return (this.event.keyCode) ? this.event.keyCode : this.event.which
        }

        keychar() {
            return String.fromCharCode(this.keycode())
        }

        shiftkey() {
            if (this.event.shiftKey)
                return true
            return false
        }

        getPathIndex = function (pathPos, path) {
            var index = 0;
            try {
                var element = path[pathPos]
                var parentElement = element.parentElement ? element.parentElement : (path.length > (pathPos + 1) ? this.path[pathPos + 1] : null)
                if (parentElement && parentElement.querySelectorAll(':scope > ' + element.nodeName).length > 1) {
                    var list = parentElement.querySelectorAll(':scope > ' + element.nodeName)
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].isSameNode(element)) {
                            index = i
                            if (element.getAttribute('PTK_originalIndex') && parseInt(element.getAttribute('PTK_originalIndex')) > 0) {
                                index = parseInt(element.getAttribute('PTK_originalIndex'))
                            }
                            break
                        }
                    }
                }
            } catch (e) {
                console.log(e)
            }
            return index
        }

        getElementXPath(element, path) {
            var paths = []
            for (var pathPos = 0; pathPos < path.length; pathPos++) {
                element = path[pathPos]
                if (element.nodeName == 'HTML')
                    break
                if (element.tagName.toUpperCase() == 'SVG' || (element.parentElement && element.parentElement.tagName.toUpperCase() == 'SVG'))
                    continue

                var xPath = element.nodeName.toUpperCase()
                if (element.id) {
                    paths.splice(0, 0, "/" + xPath + '[@id="' + element.id + '"]')
                    break
                } else if (element.name) {
                    paths.splice(0, 0, "/" + xPath + '[@name="' + element.name + '"]')
                    break
                }

                var index = this.getPathIndex(pathPos, path)
                var pathIndex = (index ? "[" + (index) + "]" : "")
                paths.splice(0, 0, xPath + pathIndex)
            }
            return "/" + paths.join("/")
        }

        getElementCssPath(element, path) {
            var paths = []
            for (var pathPos = 0; pathPos < path.length; pathPos++) {
                element = path[pathPos]
                if (element.nodeName == 'HTML')
                    break
                if (element.tagName.toUpperCase() == 'SVG' || (element.parentElement && element.parentElement.tagName.toUpperCase() == 'SVG'))
                    continue

                var cssPath = element.nodeName.toUpperCase()
                if (element.id) {
                    paths.splice(0, 0, cssPath + '[id="' + element.id + '"]')
                    break
                } else if (element.name) {
                    paths.splice(0, 0, cssPath + '[name="' + element.name + '"]')
                    break
                }

                var index = this.getPathIndex(pathPos, path)
                var pathIndex = (index ? ":nth-of-type(" + (index + 1) + ")" : "")
                paths.splice(0, 0, cssPath + pathIndex)

            }
            return paths.join(" > ")
        }

        getElementFullXPath(element, path) {
            var paths = []
            for (var pathPos = 0; pathPos < path.length; pathPos++) {
                element = path[pathPos]
                if (element.nodeName == 'HTML')
                    break;
                if (element.tagName.toUpperCase() == 'SVG' || (element.parentElement && element.parentElement.tagName.toUpperCase() == 'SVG'))
                    continue;

                var xPath = element.nodeName.toUpperCase()
                var index = this.getPathIndex(pathPos, path);
                var pathIndex = (index ? "[" + (index) + "]" : "")
                paths.splice(0, 0, xPath + pathIndex)
            }
            return "/" + paths.join("/")
        }

        getElementFullCssPath(element, path) {
            var paths = []
            for (var pathPos = 0; pathPos < path.length; pathPos++) {
                element = path[pathPos]
                if (element.nodeName == 'HTML')
                    break
                if (element.tagName.toUpperCase() == 'SVG' || (element.parentElement && element.parentElement.tagName.toUpperCase() == 'SVG'))
                    continue

                var cssPath = element.nodeName.toUpperCase()
                var index = this.getPathIndex(pathPos, path)
                let pathIndex = (index ? ":nth-of-type(" + (index + 1) + ")" : "")
                paths.splice(0, 0, cssPath + pathIndex)
            }
            return paths.join(" > ")
        }
    }

    class ptk_event_click extends ptk_event {
        constructor(e) {
            super(e)
            this.eventType = EventTypes.Click
            this.eventTypeName = "Click"
        }
    }

    class ptk_event_keypress extends ptk_event {
        constructor(e) {
            super(e)
            this.eventType = EventTypes.KeyPress
            this.eventTypeName = "SetValue"
            this.text = this.keychar()
        }
    }

    class ptk_event_navigate extends ptk_event {
        constructor(e) {
            super(e)
            this.eventType = EventTypes.Navigate
        }
    }

    class ptk_event_delay extends ptk_event {
        constructor(e) {
            super(e)
            this.eventType = EventTypes.Delay
            this.eventTypeName = "Delay"
        }
    }

    class ptk_event_change extends ptk_event {
        constructor(e) {
            super(e)
            this.eventType = EventTypes.Change
            this.eventTypeName = "Change"
        }
    }


    class ptk_testcase {
        constructor() {
            this.items = []
            browser.storage.local.get('ptk_recording_items').then(function (result) {
                if (result.ptk_recording_items) this.items = result.ptk_recording_items;
            }.bind(this))
        }

        append(item) {
            item.eventDuration = (new Date()).getTime() - item.eventStart
            if (this.items.length == 1) { //change open url duration
                var duration = item.eventStart - this.items[0].eventStart
                this.items[0].eventDuration = duration;
            }
            this.items[this.items.length] = item;
            this.sync()
        }

        sync() {
            browser.storage.local.set({ "ptk_recording_items": this.items })
        }

        peek() {
            return this.items[this.items.length - 1];
        }

        poke(o) {
            this.items[this.items.length - 1] = o;
        }

        pop = function (o) {
            this.items.pop()
        }
    }


    class ptk_recorder {
        constructor() {

            browser.storage.local.get('ptk_recording_mode').then(function (result) {
                if (result.ptk_recording_mode) this.mode = result.ptk_recording_mode;
            }.bind(this))

            this.testcase = new ptk_testcase()
            console.log(this.testcase)
        }

        start() {
            this.window = window;
            this.captureEvents();
            var actualCode = '(' + function () {
                var overloadStopPropagation = Event.prototype.stopPropagation;
                Event.prototype.stopPropagation = function () {
                    overloadStopPropagation.apply(this, arguments);
                    this.target.dispatchEvent(new MouseEvent('customRecorderEvent', this));
                };
            } + ')();';
            var script = document.createElement('script');
            script.textContent = actualCode;
            (document.head || document.documentElement).appendChild(script);
            script.parentNode.removeChild(script);
        }

        stop() {
            this.releaseEvents()
            return
        }


        captureEvents() {
            this.onlick = this.onclick.bind(this)
            document.addEventListener("click", this.onlick)

            this.onkeypress = this.onkeypress.bind(this)
            document.addEventListener("keypress", this.onkeypress)

            this.onkeydown = this.onkeydown.bind(this)
            document.addEventListener("keydown", this.onkeydown)

            document.addEventListener("paste", this.onpaste)
            document.addEventListener("change", this.onchange)
            document.addEventListener("select", this.onselect)

            this.oncustomevent = this.oncustomevent.bind(this)
            document.addEventListener("customRecorderEvent", this.oncustomevent)


            this.mutationObserver = new MutationObserver(function (mutations) {
                mutations.forEach(function (mutation) {
                    if (mutation.target.tagName == 'HEAD' || mutation.target.tagName == 'SCRIPT' || mutation.target.tagName == 'STYLE' ||
                        (mutation.target.id && mutation.target.id.toLowerCase().startsWith('ptk_')) ||
                        (mutation.target.parentElement && mutation.target.parentElement.tagName == 'BODY')) {
                        return
                    }

                    if (mutation.type == 'childList' && mutation.addedNodes.length > 0) {
                        let addedNode = mutation.addedNodes[0]
                        var count = 0
                        for (var i = 0; i < mutation.target.children.length; i++) {
                            if (mutation.target.children[i].tagName == addedNode.tagName) {
                                if (!mutation.target.children[i].getAttribute("PTK_originalIndex"))
                                    mutation.target.children[i].setAttribute("PTK_originalIndex", count)
                                count++
                            }
                        }
                    }
                    if (mutation.type == 'childList' && mutation.removedNodes.length > 0) {
                        let removedNode = mutation.removedNodes[0]
                        var count = 0
                        for (var i = 0; i < mutation.target.children.length; i++) {
                            if (mutation.target.children[i].tagName == removedNode.tagName && mutation.target.children[i].getAttribute("PTK_originalIndex")) {
                                count = parseInt(mutation.target.children[i].getAttribute("PTK_originalIndex"))
                                if (count > -1) mutation.target.children[i].setAttribute("PTK_originalIndex", (count - 1))
                            }
                        }
                    }
                })
            })

            this.mutationObserver.observe(document, {
                attributes: true,
                subtree: true,
                attributeOldValue: true,
                attributeFilter: ["class"],
                childList: true

            })

        }

        releaseEvents() {
            document.removeEventListener("click", this.onclick)
            document.removeEventListener("keypress", this.onkeypress)
            document.removeEventListener("keydown", this.onkeydown)
            document.removeEventListener("paste", this.onpaste)
            document.removeEventListener("change", this.onchange)
            document.removeEventListener("select", this.onselect)
            document.removeEventListener("customRecorderEvent", this.oncustomevent)
            this.mutationObserver.disconnect()
        }

        clickaction = function (evt) {
            let elData = null

            if (evt.elementType == "checkbox" || evt.elementType == "radio") {
                elData = new ptk_event_keypress(evt.event);
            }
            var addNewEvent = true;
            var last = this.testcase.peek();
            if (last != undefined && last.eventType == evt.eventType && (evt.eventStart - last.eventStart) < 1000) {
                addNewEvent = false;
            }

            if (addNewEvent) this.testcase.append(evt);
            if (elData != null) this.testcase.append(elData);
        }

        onclick(e) {
            if (e && e.srcElement && e.srcElement.id.startsWith('PTK_RecordingMessageCenter'))
                return false;
            let evt = new ptk_event_click(e)
            if (evt.button() == LeftButton) {
                this.clickaction(evt)
            }
            return true;
        }

        oncustomevent = function (e) {
            if (e && e.srcElement && e.srcElement.id.startsWith('PTK_RecordingMessageCenter'))
                return false;
            let evt = new ptk_event_click(e);
            if (evt.button() == LeftButton && (e.x != 0 && e.y != 0)) {
                this.clickaction(evt);
            }
            return true;
        }

        onkeypress(e) {
            e.stopImmediatePropagation();
            let evt = new ptk_event_keypress(e)
            if (evt.keycode() == 9 || evt.keycode() == 13) return false
            let last = this.testcase.peek()
            if (last && last.eventType == EventTypes.KeyPress) {
                last.text = last.text + evt.keychar();
                last.eventStart = (new Date()).getTime();
                this.testcase.poke(last);
                this.testcase.sync();
            } else {
                this.testcase.append(evt);
            }
            return false;
        }

        onkeydown(e) {
            e.stopImmediatePropagation();
            var evt = new ptk_event(e);
            if (evt.keycode() == 9 || evt.keycode() == 13) {
                setTimeout(function (e) {
                    document.activeElement.click();
                }, 100, evt)
            }
            //backspace or delete
            if (evt.keycode() == 8 || evt.keycode() == 46) {
                var selectedTxt = document.getSelection().toString(),
                    posStart = evt.event.target.selectionStart,
                    posEnd = evt.event.target.selectionEnd,
                    last = this.testcase.peek();
                if (last.eventType == EventTypes.Click) {
                    this.testcase.pop();
                    last = this.testcase.peek();
                }
                if (evt.keycode() == 46) posStart++;

                if (selectedTxt == "") {
                    if (last.eventType == EventTypes.KeyPress) {
                        var text = last.text;
                        if (last.text.length == 0) {
                            return false;
                        } else if (last.text.length == posStart) { //deleted at the end
                            text = last.text.substring(0, posStart - 1);
                        } else {
                            text = last.text.substring(0, posStart - 1);
                            text += last.text.substring(posStart, last.text.length);
                        }
                        last.text = text;
                        last.eventStart = (new Date()).getTime();
                    }
                } else {
                    last.text = last.text.replace(selectedTxt, "");
                }
                this.testcase.poke(last);
            }
            this.testcase.sync();
            return false;
        }

    }




    window.ptk_recorder = new ptk_recorder()
    window.ptk_recorder.start()


    browser.storage.local.get("ptk_recording_timing").then(function (result) {
        let entries = performance.getEntries().filter(v => ['navigation', 'resource'].includes(v.entryType))
        let storage = result.ptk_recording_timing
        let s = new Set([...storage, ...entries])
        browser.storage.local.set({
            "ptk_recording_timing": JSON.parse(JSON.stringify(Array.from(s)))
        })
    })

    // console.log("isIframe: " + window.ptk_recorder.isIframe)
    // console.log("frameindex: " + window.ptk_recorder.frameIndex)
})()


