/* Author: Denis Podgurskii */
import { ptk_SqlInjection } from "../modules/active/SqlInjection.js"
import { ptk_request } from "./request.js"
import { ptk_utils, ptk_logger } from "./utils.js"

export class ptk_rattacker {

    constructor() {
        this.attackModules = {
            SqlInjection: new ptk_SqlInjection()
        }
    }

    init(request) {
        this.scanResult = {
            items: [],
            request: request,
            stats: {
                vulnsCount: 0,
                attacksCount: 0
            }
        }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_rattacker") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_init(message) {
        return Promise.resolve({ scanResult: this.scanResult })
    }

    msg_reset(message) {
        this.init()
        return Promise.resolve({ scanResult: this.scanResult })
    }

    msg_run_scan(message) {
        let scanId = ptk_utils.UUID()
        this.runScan(scanId, message.schema)
        return Promise.resolve({ success: true, result: scanId })
    }

    async runScan(scanId, schema) {
        let request = new ptk_request()
        this.init(request.toString(schema))

        for (let key in this.attackModules) {
            let module = this.attackModules[key]
            for (let attackIndex in module.attacks) {
                let attack = module.attacks[attackIndex]
                if (attack.location.includes('Post')) {
                    let modifiedSchema = JSON.parse(JSON.stringify(schema))

                    let params = modifiedSchema.request.body.split('&')
                    for (let i in params) {
                        params[i] = attack.position == 'before' ? params[i].replace('=', '=' + attack.attackValue) : params[i] + attack.attackValue
                    }
                    modifiedSchema.request.body = params.join('&')
                    modifiedSchema.asString = request.toString(modifiedSchema)
                    await this.runPostAttack(scanId, modifiedSchema, attack, module.vulnRegex)
                }
            }
        }
    }

    modifyParams(params, options) {

    }

    runPostAttack(scanId, schema, attack, vulnRegex) {
        let request = new ptk_request()
        schema.request.followRedirect = true
        return request.sendRequest(schema).then((result) => {
            let body = result.body, re = new RegExp(vulnRegex)
            let item = {
                attack: attack,
                request: btoa(request.toString(schema)),
                baseUrl: schema.request.url,
                body: btoa(body),
                headers: btoa(result.headers)
            }

            this.scanResult.stats.attacksCount++
            if (re.test(body)) {
                item.success = true
                item.proof = btoa(body.match(re)[0])
                this.scanResult.stats.vulnsCount++
                console.log("match found")
            } else {
                item.success = false
                item.proof = ""
                console.log("match NOT found")
            }
            this.scanResult.items.push(item)
            browser.runtime.sendMessage({
                channel: "ptk_background2popup_rattacker",
                type: "attack completed",
                info: item,
                scanResult: this.scanResult
            }).catch(e =>
                ptk_logger.log(e, "Could not send a message", "info")
            )
        }).catch(function (error) {
            ptk_logger.log(e, "Could not run an attack", "info")
        })
    }

}
