/* Author: Denis Podgurskii */
import { ptk_logger, ptk_utils } from "./utils.js"

export class ptk_request {

    constructor() {
        this.pentestkitRequest = { cookie: {}, statusLine: "", headers: new Map() }
        this.addListeners()
        this.addMessageListeners()
    }

    /* Listeners */

    addListeners() {

        this.onBeforeSendHeaders = this.onBeforeSendHeaders.bind(this)
        browser.webRequest.onBeforeSendHeaders.addListener(
            this.onBeforeSendHeaders,
            { urls: ["<all_urls>"], types: ptk_utils.filterType },
            ["blocking", "requestHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        this.onHeadersReceived = this.onHeadersReceived.bind(this);
        browser.webRequest.onHeadersReceived.addListener(
            this.onHeadersReceived,
            { urls: ["<all_urls>"], types: ptk_utils.filterType },
            ["blocking", "responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
    }

    removeListeners() {
        browser.webRequest.onBeforeSendHeaders.removeListener(this.onBeforeSendHeaders)
        browser.webRequest.onHeadersReceived.removeListener(this.onHeadersReceived)
    }

    onBeforeSendHeaders(request) {
        //Request from PTK request builder or Scan
        let x_ptkHeader = request.requestHeaders.find(obj => { return obj.name == "x-penetrationtestingkitheaders" })
        if (x_ptkHeader) {
            let jsonHeaders = JSON.parse(atob(x_ptkHeader.value))
            this.pentestkitRequest.headers.set(request.requestId, [])
            if (this.pentestkitRequest.cookie.length > 0) {
                if (jsonHeaders.filter(x => x.name == 'Cookie').length > 0) {
                    jsonHeaders.filter(x => x.name == 'Cookie')[0].value = jsonHeaders.filter(x => x.name == 'Cookie')[0].value + "" + this.pentestkitRequest.cookie.map(x => x.name + "=" + x.value).join("")
                } else {
                    jsonHeaders.push({ name: "Cookie", value: this.pentestkitRequest.cookie.map(x => x.name + "=" + x.value).join("") })
                }
            }
            return { requestHeaders: jsonHeaders }
        }
        return { requestHeaders: request.requestHeaders }
    }

    onHeadersReceived(response) {
        if (this.pentestkitRequest.headers.has(response.requestId)) {
            this.pentestkitRequest.cookie = response.responseHeaders.filter(x => x.name.toLowerCase() == 'set-cookie').map(
                x => {
                    let parts = x.value.split("").filter(item => typeof item === "string" && !!item.trim())
                    let nameValue = parts.shift().split("=")
                    let name = nameValue.shift()
                    let value = nameValue.join("=")
                    return {
                        name: name,
                        value: value
                    }
                }
            )
            this.pentestkitRequest.statusLine = response.statusLine
            this.pentestkitRequest.headers.set(response.requestId, response.responseHeaders)
        }

        return { responseHeaders: response.responseHeaders }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_request") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_parse_request(message) {
        let schema = this.parseRawRequest(message.item)
        schema.request.asString = schema.toString()
        return Promise.resolve(JSON.parse(JSON.stringify(schema)))
    }

    msg_update_request(message) {
        let schema = this.updateRawRequest(message.item)
        schema.request.asString = schema.toString()
        return Promise.resolve(JSON.parse(JSON.stringify(schema)))
    }

    msg_send_request(message) {
        return this.sendRequest(message.schema).then(function (response) {
            return Promise.resolve(response)
        })
    }

    /* End Listeners */

    validate = function (message) {
        if (message && message.function == 'validate') {
            browser.windows.create({
                url: browser.extension.getURL("browser/requestbuilder.html?validateRequest=" + message.parameters),
                type: "popup",
                'width': 1200,
                'height': 700
            })
        }
    }

    updateRawRequest(requestObject) {

        if (!requestObject.request_url.startsWith(requestObject.request_protocol + "://"))
            requestObject.request_url = requestObject.request_protocol + "://" + requestObject.request_url.replace(/^https?:\/\//, '')

        if (requestObject.request.trim() == "") {
            requestObject.request = requestObject.request_method + " " + requestObject.request_url + " HTTP/1.1"
        } else {
            let requestData = requestObject.request.trim().split(/\r?\n/)
            requestData[0] = requestObject.request_method + " " + requestObject.request_url + " HTTP/1.1"
            requestObject.request = requestData.join('\n')
        }
        let schema = this.parseRawRequest(requestObject)

        return schema
    }

    parseRawRequest(requestObject) {
        let schema = this.requestSchema()
        let requestData = requestObject.request.trim().split(/\n\n/)
        let headerArray = requestData[0].split(/\r?\n/)

        let host = null
        if (headerArray.filter(x => x.includes('Host:')).length != 0) {
            let h = headerArray.filter(x => x.includes('Host:'))[0].split(":")
            h.shift()
            host = h.join(":").trim()
        }

        let requestString = headerArray.shift()
        if (requestString.toUpperCase().match(/(^GET|^POST|^HEAD|^PUT|^DELETE|^OPTIONS)/)) {
            let requestArray = requestString.split(' ')
            if (requestArray[1].startsWith('http')) {
                schema.request.url = new URL(requestArray[1])
                //Add Host header if doesn't exist
                if (headerArray.filter(x => x.includes('Host:')).length == 0) {
                    headerArray.push('Host: ' + schema.request.url.host)
                } else {
                    headerArray[headerArray.findIndex(x => x.includes('Host:'))] = 'Host: ' + schema.request.url.host
                }
            } else {
                if (!host)
                    throw 'Host value not defined. Use an absolute URL or add "Host" header.'
                let baseUrl = requestObject.request_protocol + "://" + host
                schema.request.url = new URL(requestArray[1], baseUrl)
            }
            schema.request.method = requestArray[0].trim()
            schema.request.version = requestArray[2]
            schema.request.protocol = schema.request.url.protocol
            schema.request.host = schema.request.url.host
        }

        schema.request.headers = headerArray;
        if (requestData.length > 1 && schema.request.method != 'GET' && schema.request.method != 'HEAD') {
            schema.request.body = requestData[1]
        }
        return schema
    }

    sendRequest(schema) {

        let x_pentestkitHeaders = btoa(JSON.stringify(schema.request.headers.map(x => {
            let h = x.split(':')
            if (h.length > 2) return { name: h.shift(), value: h.join(":") }
            return { name: h[0], value: h[1] }
        })))

        let rHeaders = new Headers(schema.request.headers.map(x => {
            let h = x.split(':')
            if (h.length > 2) return [h.shift(), h.join(":")]
            return h
        }))
        rHeaders.append('x-penetrationtestingkitheaders', x_pentestkitHeaders)

        let params = {
            method: schema.request.method,
            mode: 'cors',
            redirect: schema.request.followRedirect ? "follow" : "manual",
            credentials: 'same-origin',
            cache: 'no-cache',
            headers: rHeaders
        }
        if (schema.request.body && !schema.request.method.toUpperCase().match(/(^GET|^HEAD)/)) {
            params.body = schema.request.body
        }
        let request = new Request(schema.request.url, params)


        return fetch(request).then(function (response) {
            let headers = this.pentestkitRequest.statusLine + "\n"
            this.pentestkitRequest.headers.forEach(function (value, key) {
                value.forEach(function (val, key) {
                    headers += (val.name != "" ? val.name + ": " : "") + val.value + "\r\n"
                })
            })

            this.pentestkitRequest.cookie = {}
            this.pentestkitRequest.statusLine = ""
            this.pentestkitRequest.headers.clear()
            //this.removeListeners()

            return response.text().then(function (body) {
                return { headers: headers, body: body }
            })
        }.bind(this))

    }

    requestSchema() {
        return {
            request: {
                method: '',
                headers: [],
                cookie: [],
                body: '',
                version: '',
                url: null,
                host: null,
                protocol: null,
                followRedirect: true
            },
            response: {
                headers: [],
                content: ''
            },
            toString: function () {
                let r = this.request.method + ' ' + this.request.url + ' ' + this.request.version + '\n' + this.request.headers.join('\n')
                if (this.request.body) r += '\n\n' + this.request.body
                return r
            }
        }
    }

}