/* Author: Denis Podgurskii */

export class ptk_exporter {

    constructor(recording, settings) {
        this.items = recording.items
        this.frames = recording.frames
        this.request = recording.recordingRequests
        this.settings = settings
    }

    render() {
        if (this['render_' + this.settings.format]) return this['render_' + this.settings.format]()
        else throw 'No render methond for ' + this.settings.format
    }

    /* xml */
    render_xml() {
        let macro = '<?xml version="1.0"?>\r\n<MacroEventList>'
        for (let i = 0; i < this.items.length; i++) {
            macro += this.renderXmlEvent(this.items[i])
        }
        macro += '\r\n</MacroEventList>'
        return macro
    }

    renderXmlEvent(item) {
        let eventTypeName = this.getXmlEventName(item.eventTypeName),
            data = this.getXmlEventData(item),
            path = this.getXPath(item),
            duration = item.eventDuration ? item.eventDuration : this.settings.minDuration,
            windowIndex = item.windowIndex,
            frameIndex = (item.frameIndex && item.frameIndex != -1) ? item.frameIndex : 0

        return `
  <MacroEvent>
    <WindowIndex>${windowIndex}</WindowIndex>
    <EventType>${eventTypeName}</EventType>
    <UseEncryptedData>0</UseEncryptedData>
    <Data><![CDATA[${data}]]></Data>
    <EncryptedData></EncryptedData>
    <ElementPath><![CDATA[${path}]]></ElementPath>
    <Duration>${duration}</Duration>
    <Enable>1</Enable>
    <Optional>0</Optional>
    <FrameIndex>${frameIndex}</FrameIndex>
  </MacroEvent>`
    }

    getXmlEventName(eventTypeName) {
        let r = eventTypeName
        switch (eventTypeName) {
            case 'Click':
                r = "DriverClick"
                if (this.settings.eventType == "javascript") r = "Javascript"
                if (this.settings.eventType == "onclick") r = "OnClick"
                break
            case 'SetValue':
                r = "DriverSetControlValue"
                if (this.settings.eventType == "javascript") r = "Javascript"
                if (this.settings.eventType == "onclick") r = "SetControlData"
                break
        }
        return r
    }

    getXmlEventData(item) {
        let r = item.data ? item.data : ""
        if (this.settings.eventType == 'javascript') {
            let path = this.settings.elementPath == 'id' ? item.csspath : item.fullcsspath
            switch (item.eventTypeName) {
                case "Click":
                    r = this.javascriptClickEvent(item.data, path)
                    break;
                case "SetValue":
                    r = this.javascriptSetControlValueEvent(item.data, path)
                    break
            }
        }
        return r
    }

    getXmlIframePath(frameIndex) {
        if (!this.frames[frameIndex]) return ""
        let frame = this.frames[frameIndex]
        if (frame?.id) return `//IFRAME[@id="${frame.id}"]|||>xpath=`
        if (frame?.name) return `//IFRAME[@name="${frame.name}"]|||>xpath=`
        if (frame?.title) return `//IFRAME[@title="${frame.title}"]|||>xpath=`
    }

    getXPath(item) {
        let path = this.getXmlIframePath(item.frameIndex)
        if (this.settings.elementPath == 'id' && item.xpath) path += item.xpath
        if (this.settings.elementPath == 'fullpath' && item.fullxpath) path += item.fullxpath
        if (path) path = 'xpath=' + path
        return path
    }

    /* har */

    render_har() {



        let pages = [], entries = [], requestId = -1
        this.request.forEach(function (item) {
            let postData = null,
                requestHeaders = item.requestHeaders ? item.requestHeaders : [],
                responseHeaders = item.responseHeaders ? item.responseHeaders : [],
                requestHeaderSize = 0

            if (item.type == "main_frame" && requestId != item.requestId) {
                var page = {
                    "startedDateTime": (new Date(item.request.timeStamp).toISOString()),
                    "id": item.requestId,
                    "title": item.request.url,
                    "pageTimings": {
                        "onContentLoad": item.timing?.domContentLoadedEventEnd ? item.timing?.domContentLoadedEventEnd : -1,
                        "onLoad": item.timing?.loadEventEnd ? item.timing?.loadEventEnd : -1
                    }
                };
                pages.push(page);
                requestId = item.requestId;
            }

            var cookies = [];
            if (item.requestHeaders.find(item => item.name == 'Cookie')) {
                item.requestHeaders.find(item => item.name == 'Cookie').value.split('; ').reduce(function (result, v, i, a) {
                    var k = v.split('=');
                    cookies.push({ "name": k[0], "value": k[1], "expires": null, "httpOnly": false, "secure": false });
                }, {});
            }


            if (item.request.postData) {
                postData = {};
                postData.mimeType = item.request.headers['Content-Type'];
                postData.text = item.request.requestBody;
                var postArray = [];
                try {
                    try {
                        postArray = JSON.parse(item.request.postData);
                    } catch (e) {
                        postArray = JSON.parse('{"' + decodeURI(item.request.postData).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
                    }
                    postData.params = Object.keys(postArray).map(name => ({ name, value: postArray[name] }));
                } catch (e) {
                    console.log(e)
                }
            }
            let status = item.response.statusLine?.split(' ')
            let httpVersion = status? status[0] : ""
            status?.splice(0,1)
            let statusCode = status? status[0] : ""
            status?.splice(0,1)
            let statusText = status? status.join(' ') : ""

            var entry = {
                "startedDateTime": (new Date(item.request.timeStamp).toISOString()),
                "time": item.timing?.duration,
                "request": {
                    "method": item.request.method,
                    "url": item.request.url,
                    "httpVersion": httpVersion,
                    "headers": requestHeaders,
                    "queryString": [],
                    "cookies": cookies,
                    "headersSize": requestHeaderSize,
                    "bodySize": 0
                },
                "response": {
                    "status": statusCode,
                    "statusText": statusText,
                    "httpVersion": (item.response && item.response.protocol) ? item.response.protocol.toUpperCase() : "HTTP/1.1",
                    "headers": responseHeaders,
                    "cookies": [],
                    "content": {
                        "size":  item.response.body ? item.response.body.length : 0,
                        "mimeType": (item.response && item.response.mimeType) ? item.response.mimeType : "",
                        "compression": 0,
                        "text": (item.responseBody && item.responseBody.body) ? item.responseBody.body : "",
                        "encoding": (item.responseBody && item.responseBody.base64Encoded) ? "base64" : ""
                    },
                    "redirectURL": "",
                    "headersSize": (item.response && item.response.headersText ? item.response.headersText.length : 0),
                    "bodySize": (item.responseBody && item.responseBody.body) ? item.responseBody.body.length : 0
                },
                "cache": {},
                "timings": {
                    "send": -1,
                    "receive": -1,
                    "wait": -1
                },
                "serverIPAddress": item.serverIPAddress,
                "pageref": requestId
            };

            if (postData != null) {
                entry.request.postData = postData;
            }
            entries.push(entry);
        })

        return {
            "log": {
                "version": "1.0",
                "creator": {
                    "name": "PTK",
                    "version": "6.0.0"
                },
                pages: pages.reverse(),
                entries: entries
            }
        };
    }

    /* javascript */
    javascriptGetMacroItem(path, attrs) {
        let output = "";
        if (attrs.length > 0 && path == "") {
            if (attrs[0] == 'a') {
                output += `let item = Array.prototype.slice.call(document.querySelectorAll('ptk_ATTRNAME_ptk')).filter(function (el) { return el.textContent === 'ptk_ATTRVALUE_ptk'})[0];
            `.replace(/ptk_ATTRNAME_ptk/g, attrs[0]).replace(/ptk_ATTRVALUE_ptk/g, attrs[1]);;
            } else {
                path = '[' + attrs[0] + ' = "' + attrs[1] + '"]';
                output += `let item = document.querySelector('ptk_PATH_ptk'); `.replace(/ptk_PATH_ptk/g, path);
            }
        } else {
            output += `let item = document.querySelector(path); `

        }
        return output;
    }

    javascriptSetControlValueEvent(data, path, attrs = []) {
        let js = this.javascriptGetMacroItem(path, attrs)
        return `
        (function(path, data){
            ${js}
            let lastValue = item.value
            let event = new Event('input', {bubbles: true})
            event.simulated = true
            item.value = data
            item.defaultValue = data
            let tracker = item._valueTracker
            if (tracker) { tracker.setValue(lastValue) }
            item.dispatchEvent(event)
            item.dispatchEvent(new Event('change', {bubbles: true}))
            item.dispatchEvent(new Event('blur', {bubbles: true}))
            item.dispatchEvent(new Event('resize', {bubbles: true}))
        })('${path}', \`${data}\`)
        `
    }

    javascriptClickEvent(data, path, attrs = []) {
        let js = this.javascriptGetMacroItem(path, attrs)
        return `
        (function(path){
            ${js}
            item.click()
            item.dispatchEvent(new Event('resize', {bubbles: true}))
        })('${path}')
        `
    }

}