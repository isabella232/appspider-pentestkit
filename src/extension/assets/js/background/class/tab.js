/* Author: Denis Podgurskii */

/*
{frames: new Map[ frameId: new Map [requestId: [item: {request: object, response: object} ] ] ] }
*/
import { ptk_logger, ptk_utils } from "./utils.js"

export class ptk_tabs {
    constructor(maxTabs, maxRequestsPerTab) {
        this.maxTabsCount = maxTabs
        this.maxRequestsPerTab = maxRequestsPerTab

        this.tabs = {}
        this.activeTab = {}
        this.isTabsCapturingActive = true
        this.addListiners()
    }

    /* Listeners */

    addListiners() {
        browser.tabs.onActivated.addListener(this.onActivated.bind(this))
        
        browser.webRequest.onBeforeRequest.addListener(this.onBeforeRequest.bind(this),
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["blocking", "requestBody"].concat(ptk_utils.extraInfoSpec)
        )
        browser.webRequest.onSendHeaders.addListener(
            this.onSendHeaders.bind(this),
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["requestHeaders"].concat(ptk_utils.extraInfoSpec)
        )
        browser.webRequest.onBeforeRedirect.addListener(
            this.onBeforeRedirect.bind(this),
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
        browser.webRequest.onCompleted.addListener(
            this.onCompleted.bind(this),
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
    }

    onActivated(info) {
        ptk_logger.log("ptk_tabs onActivated", { tabId: info.tabId, window: info.windowId, info: info })
        browser.tabs.query({
            currentWindow: true, active: true
        }).then(function (tabs) {
            var tab = tabs[0]
            if (!tab || tab.url.match("-extension(s)?://") ||
                (tab.pendingUrl && tab.pendingUrl.match("-extension(s)?://"))) return

            this.activeTab = { tabId: info.tabId, window: info.windowId }
        }.bind(this))
    }

    onBeforeRequest(request) {
        ptk_logger.log("ptk_tabs onBeforeRequest", { tabId: request.tabId, request: request.requestId, request: request })
        this.setTab(request.tabId, request, 'start')
    }

    onSendHeaders(request) {
        ptk_logger.log("ptk_tabs onSendHeaders", { tabId: request.tabId, request: request.requestId, request: request })
        this.setTab(request.tabId, request, 'request')
    }

    onBeforeRedirect(response){
        ptk_logger.log("onBeforeRedirect", { tabId: response.tabId, request: response.requestId, response: response })
        this.setTab(response.tabId, response, 'redirect')
    }

    onCompleted(response){
        ptk_logger.log("onCompleted", { tabId: response.tabId, request: response.requestId, response: response })
        this.setTab(response.tabId, response, 'response')
    }

    /* End Listeners */

    setTab(tabId, params, t) {
        if (t != 'clientApps') {
            //Listen only active tab
            if (!this.isTabsCapturingActive || this.activeTab == null || tabId != this.activeTab.tabId) return
            //do not add chrome extensions
            if (params.url && params.url.match("-extension(s)?://")) return
        }
        this.updateTab(tabId, params, t)
    }

    getTab(tabId) {
        if (tabId in this.tabs && this.tabs[tabId] instanceof ptk_tab) return this.tabs[tabId]
        return null
    }

    updateTab(tabId, params, t) {
        try {
            if (tabId in this.tabs && this.tabs[tabId] instanceof ptk_tab) {
                this.tabs[tabId].setParams(params, t)
                ptk_logger.log("Tab updated ", { tabId: tabId })
            } else {
                this.tabs[tabId] = new ptk_tab(tabId, params, t)
                this.reduceTabs(this.maxTabsCount, tabId)
                ptk_logger.log("Tab added ", { tabId: tabId })
            }
            this.tabs[tabId].reduceTabSize(this.maxRequestsPerTab)
        } catch (e) {
            ptk_logger.log(e, "Could not update a tab", "error")
        }
    }



    clearTab(tabId) {
        delete this.tabs[tabId]
    }

    activateTabsCapturing(info, tab) {
        this.isTabsCapturingActive = true
    }

    deactivateTabsCapturing(info, tab) {
        this.isTabsCapturingActive = false
    }

    reduceTabs(maxTabs, newTabId) {
        let tabsCount = Object.keys(this.tabs).length
        if (tabsCount <= maxTabs) return
        let removeKey = [], count = 0
        Object.keys(this.tabs).forEach(key => {
            if ((tabsCount - count) > maxTabs && key != newTabId) {
                removeKey.push(key)
                count++
            }
        })
        if (removeKey.length > 0) {
            removeKey.forEach((tabId) => {
                delete this.tabs[tabId]
            })
        }
    }

    set activeTab(s) {
        this._previousTab = this._activeTab
        this._activeTab = s
        browser.runtime.sendMessage({
            channel: "ptkBackgroundToPopup",
            type: "active tab changed"
        }).catch(e => ptk_logger.log(e, "Could not set active tab", "info"))
    }

    get activeTab() {
        return this._activeTab
    }
}

export class ptk_tab {
    constructor(tabId, params, type) {
        this.tabId = tabId
        this.frames = new Map()
        this.setParams(params, type)
    }

    setParams(params, type) {
        if (Number.isInteger(params.frameId)) {
            //Init frame map if doesn't exist
            if (!this.frames.has(params.frameId)) {
                this.frames.set(params.frameId, new Map())
                ptk_logger.log("Init frames", { frameId: params.frameId, requestId: params.requestId })
            }
            //Init request map if doesn't exist
            if (!this.frames.get(params.frameId).has(params.requestId)) {
                this.frames.get(params.frameId).set(params.requestId, new Array())
            }
            var index = this.frames.get(params.frameId).get(params.requestId).length
            if (type == 'start' || index == 0) {
                this.frames.get(params.frameId).get(params.requestId).push(params)
                ptk_logger.log("Add new item for ", { frameId: params.frameId, requestId: params.requestId })
            } else {
                for (var p in params) {
                    let requestKey = index == 0 ? 0 : index - 1
                    if (this.frames.get(params.frameId).get(params.requestId)[requestKey][p] != params[p]) {
                        this.frames.get(params.frameId).get(params.requestId)[requestKey][p] = params[p]
                    }
                }
                ptk_logger.log("Updated params ", { params: params, frameId: params.frameId, requestId: params.requestId })
            }
        } else {
            for (var p in params) {
                this[p] = params[p]
                ptk_logger.log("Add or update param ", { p: params[p] })
            }
        }
    }

    reduceTabSize(maxRequest) {
        this.frames.forEach((frame, fkey) => {
            frame.forEach((request, rkey) => {
                if (frame.size >= maxRequest) {
                    frame.delete(rkey)
                }
            })
        })
        browser.runtime.sendMessage({
            channel: "ptkBackgroundToPopup",
            type: "requests source resized"
        }).catch(e => ptk_logger.log(e, "Could not send a message", "info"))
    }

}