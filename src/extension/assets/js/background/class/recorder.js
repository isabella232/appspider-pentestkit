/* Author: Denis Podgurskii */

import { ptk_logger, ptk_notifications, ptk_utils } from "./utils.js"

export class ptk_recorder {
    constructor() {
        delete window.ptk_recorder_active
        this.mode = null // recording || replay
        this.type = null // macro || traffic || bootstrap
        this.openerWinId = 0
        this.openerTabId = 0
        this.tabs = []

        this.recorderJS = "assets/js/content/recorder.js"
        this.trackerJS = "assets/js/content/tracker.js"
        this.replayerJS = "assets/js/content/replayer.js"

        this.replay = null
        this.recording = null
        this.bootstrap = null

        this.savedMacro = ""
        this.addMessageListeners()
    }

    /* Listeners */

    addListiners() {
        this.onActivated = this.onActivated.bind(this)
        browser.tabs.onActivated.addListener(this.onActivated)

        this.onUpdated = this.onUpdated.bind(this)
        browser.tabs.onUpdated.addListener(this.onUpdated)

        this.onRemoved = this.onRemoved.bind(this)
        browser.tabs.onRemoved.addListener(this.onRemoved)

        this.onBeforeRequest = this.onBeforeRequest.bind(this)
        browser.webRequest.onBeforeRequest.addListener(this.onBeforeRequest,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["blocking", "requestBody"].concat(ptk_utils.extraInfoSpec)
        )

        this.onSendHeaders = this.onSendHeaders.bind(this)
        browser.webRequest.onSendHeaders.addListener(this.onSendHeaders,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["requestHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        this.onHeadersReceived = this.onHeadersReceived.bind(this)
        browser.webRequest.onHeadersReceived.addListener(this.onHeadersReceived,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        this.onCompleted = this.onCompleted.bind(this)
        browser.webRequest.onCompleted.addListener(this.onCompleted,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )

    }

    removeListiners() {
        browser.tabs.onActivated.removeListener(this.onActivated)
        browser.tabs.onUpdated.removeListener(this.onUpdated)
        browser.tabs.onRemoved.removeListener(this.onRemoved)

        browser.webRequest.onBeforeRequest.removeListener(this.onBeforeRequest)
        browser.webRequest.onSendHeaders.removeListener(this.onSendHeaders)
        browser.webRequest.onHeadersReceived.removeListener(this.onHeadersReceived)
    }

    onActivated(info) {
        if (this.mode != null) {
            this.tabs.push(info.tabId)
        }
    }

    onUpdated(tabId, info, tab) {
        if (info.status != "complete" || !this.isTracking(tabId)) return

        let self = this
        if (this.mode == "recording") {
            browser.tabs.executeScript(tabId, { file: self.trackerJS, matchAboutBlank: true, allFrames: false, runAt: "document_start" })
            browser.tabs.executeScript(tabId, { file: self.recorderJS, matchAboutBlank: true, allFrames: true, runAt: "document_start" })

        } else if (this.mode == "replay") {
            browser.tabs.executeScript(tabId, { file: self.trackerJS, matchAboutBlank: true, allFrames: false, runAt: "document_start" })
            browser.tabs.executeScript(tabId, { file: self.replayerJS, matchAboutBlank: true, allFrames: true, runAt: "document_start" })
        }
    }

    onRemoved(tabId, info) {
        if (tabId == this.openerTabId) {
            if (this.mode == "recording") this.stopRecording(info)
            else if (this.mode == "replay") this.stopReplay(info)
        }
    }

    onBeforeRequest(request) {
        if (request.url.match(/(^wss:|-extension(s)?:)/) || request.type.match(/(ping)/)) return
        if(!this.isTracking(request.tabId)) return

        if (this.mode == "recording") {
            try {
                let item = {
                    requestId: request.requestId, type: request.type, request: request, response: {}
                }

                this.recording.recordingRequests.push(item)

                if (window.isFirefox) {
                    let filter = browser.webRequest.filterResponseData(item.requestId)
                    let decoder = new TextDecoder("utf-8")

                    filter.ondata = (event => {
                        let str = decoder.decode(event.data, { stream: true })
                        filter.write(event.data)
                        filter.disconnect()
                        let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, item.requestId)]
                        r.response.body = str
                        r.response.base64Encoded = false
                    }).bind(this)
                }
            }
            catch (e) { e => ptk_logger(e, "Could not update recording request", "warning") }
        }
    }

    onSendHeaders(request) {
        if(!this.isTracking(request.tabId)) return
        if (this.mode == "recording") {
            let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, request.requestId)]
            if (r) r.requestHeaders = request.requestHeaders
        }
    }

    onHeadersReceived(response) {
        if(!this.isTracking(response.tabId)) return
        if (this.mode == "recording") {
            let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, response.requestId)]
            if (r) {
                r.responseHeaders = response.responseHeaders
                r.response.statusCode = response.statusCode
                r.response.statusLine = response.statusLine
            }
        }
    }

    onCompleted(response) {
        if(!this.isTracking(response.tabId)) return
        if (this.mode == "recording") {
            let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, response.requestId)]
            if (r) {
                r.serverIPAddress = response.ip
            }
        }
    }

    onStart(win, startUrl) {
        this.openerWinId = win.id
        this.openerTabId = win.tabs[0].id
        if (!window.isFirefox && this.mode == 'recording') {
            //Attach debugger
            let debugTarget = { tabId: this.openerTabId }
            chrome.debugger.attach(debugTarget, "1.3", this.onAttach())
            chrome.debugger.sendCommand(debugTarget, "Network.setCacheDisabled", { cacheDisabled: true })
            chrome.debugger.sendCommand(debugTarget, "Network.enable");
        }
        browser.windows.update(win.id, { "focused": true })
        browser.tabs.update(this.openerTabId, { url: startUrl })
    }

    findLastIndex(obj, requestId) {
        let l = obj.length
        while (l--) {
            if (obj[l].requestId == requestId) return l
        }
        return -1
    }

    onAttach(tabId) {
        this.onEvent = this.onEvent.bind(this)
        chrome.debugger.onEvent.addListener(this.onEvent)
        this.onDetach = this.onDetach.bind(this)
        chrome.debugger.onDetach.addListener(this.onDetach)
    }

    onDetach(source, reason) {
        chrome.debugger.onEvent.removeListener(this.onEvent)
        chrome.debugger.onDetach.removeListener(this.onDetach)
    }

    onEvent(debuggeeId, message, params) {

        if (!this.isTracking(debuggeeId.tabId)) return
        if (params.request && params.request.url && params.request.url.includes("-extension://")) return
        if (params.response && params.response.url && params.response.url.includes("-extension://")) return

        let item = {
            requestId: params.requestId,
            parentId: params.loaderId,
            type: params.type,
            response: {},
            timing: {}
        }
        let reverseIndex = this.findLastIndex(this.recording.requests, item.requestId)

        if (message == "Network.requestWillBeSent") {
            if (params.redirectResponse ||
                !this.recording.requests.some(e => e.requestId === params.requestId)) {
                item.request = params.request
                this.recording.requests.push(item)
            }
        }
        if (message == "Network.loadingFinished" && reverseIndex > -1) {
            chrome.debugger.sendCommand(debuggeeId, "Network.getResponseBody", { "requestId": params.requestId },
                function (response) {
                    this.recording.requests[reverseIndex].response.body = response.body
                    this.recording.requests[reverseIndex].response.base64Encoded = response.base64Encoded
                }.bind(this))

        }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_recorder") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_init(message) {
        return Promise.resolve({ savedMacro: this.savedMacro, recording: this.recording })
    }

    msg_save(message) {
        this.savedMacro = message.macro
        return Promise.resolve({ result: true })
    }

    msg_reset(message) {
        this.reset()
        return Promise.resolve({ result: true })
    }

    msg_analyse(message) {
        return Promise.resolve(this.analyse())
    }

    msg_start_macro(message) {
        this.startMacro(message.cleanCookie, message.url)
        return Promise.resolve({ result: true })
    }

    msg_start_traffic(message) {
        this.startTraffic(message.cleanCookie, message.url)
        return Promise.resolve({ result: true })
    }
    

    msg_replay(message) {
        this.startReplay(message.cleanCookie, message.url, message.events, message.validateRegex)
        return Promise.resolve()
    }

    /* End Listeners */

    isTracking(tabId) {
        return (tabId == this.openerTabId || this.tabs.includes(tabId))
    }

    cleanCookie(startUrl) {
        browser.cookies.getAll({ domain: (new URL(startUrl)).hostname }).then(function (cookies) {
            let url = new URL(startUrl)
            for (let i = 0; i < cookies.length; i++) {
                browser.cookies.remove({
                    url: url.protocol + "//" + cookies[i].domain + cookies[i].path,
                    name: cookies[i].name
                })
            }
        })
    }

    startRecording(cleanCookie, startUrl) {
        if (this.mode == null) {
            this.reset()

            window.ptk_recorder_active = true
            this.mode = 'recording'

            this.recording = {
                startUrl: startUrl, cleanCookie: cleanCookie, frames: [], items: [], requests: [], recordingRequests: []
            }

            if (cleanCookie) this.cleanCookie(startUrl)

            this.addListiners()
            browser.webRequest.handlerBehaviorChanged() //FF caching
            browser.storage.local.set({
                "ptk_recording_frames": [],
                "ptk_recording_items": [],
                "ptk_recording_timing": [],
                "ptk_recording": { mode: "recording", startUrl: startUrl }
            }).then(function () {
                browser.windows.create({ url: 'about:blank', type: "popup" })
                    .then(
                        function (win) { this.onStart(win, startUrl) }.bind(this))
            }.bind(this))

        } else {
            ptk_notifications.notify("Recording/playback already started", "Stop recording before start a new one");
        }
    }

    stopRecording(params) {
        window.ptk_recorder_active = false
        this.mode = null
        this.openerWinId = -1
        this.openerTabId = -1
        this.tabs = []
        this.removeListiners()

        browser.storage.local.get(["ptk_recording_frames", "ptk_recording_items", "ptk_recording_timing"]).then(function (result) {
            if (!result) return

            let a = this.recording.requests
            let b = result.ptk_recording_timing

            for (let l = 0; l < this.recording.recordingRequests.length; l++) {

                for (let k = 0; k < a.length; k++) {
                    let r = a[k].request
                    let u = r.urlFragment ? r.url + r.urlFragment : r.url
                    if (this.recording.recordingRequests[l].request.url == u) {
                        this.recording.recordingRequests[l].response.body = a[k].response.body
                        this.recording.recordingRequests[l].response.base64Encoded = a[k].response.base64Encoded
                        a.splice(k, 1)
                        break
                    }
                }

                for (let k = 0; k < b.length; k++) {
                    if (this.recording.recordingRequests[l].request.url == b[k].name) {
                        this.recording.recordingRequests[l].timing = b[k]
                        b.splice(k, 1)
                        break
                    }
                }
            }
            this.recording.requests = []
            console.log(result)
            console.log(this.recording.recordingRequests)


            this.recording.frames = result.ptk_recording_frames
            this.recording.items = result.ptk_recording_items

            browser.storage.local.remove(["ptk_recording", "ptk_recording_frames", "ptk_recording_items", "ptk_recording_timing"])
            browser.runtime.sendMessage({
                channel: "ptk_background2popup_recorder",
                type: "recording_completed",
                recording: this.recording
            }).catch(e => ptk_logger.log(e, "Could send recording completed", "warning"))

        }.bind(this))
    }

    startMacro(cleanCookie, startUrl) {
        this.type = "macro"
        this.startRecording(cleanCookie, startUrl)
    }

    startTraffic(cleanCookie, startUrl) {
        this.type = "traffic"
        this.startRecording(cleanCookie, startUrl)
    }

    startBootstrap(cleanCookie, startUrl, bootstrapDetails) {
        this.type = "bootstrap"
        this.bootstrap = {
            bootstrapJobID: null, bootstrapEndpoint: null, bootstrapPutParams: null, bootstrapUsePut: false
        }
        this.startRecording(cleanCookie, startUrl)
    }

    startReplay(cleanCookie, startUrl, items, validateRegex) {
        if (this.mode == null) {

            window.ptk_recorder_active = true
            this.mode = 'replay'

            this.replay = {
                startUrl: startUrl, replayStep: 0, replayEvents: items, validateRegex: validateRegex
            }

            if (cleanCookie) this.cleanCookie(startUrl)
            this.addListiners()
            return browser.storage.local.set({
                "ptk_replay_items": items,
                "ptk_replay_step": 0,
                "ptk_replay": { mode: "replay", startUrl: startUrl }
            }).then(function () {
                browser.windows.create({ url: 'about:blank', type: "popup" })
                    .then(
                        function (win) { this.onStart(win, startUrl) }.bind(this))
            }.bind(this))

        } else {
            ptk_notifications.notify("Recording/playback already started", "Stop recording before start a new one");
        }
    }

    stopReplay(params) {
        window.ptk_recorder_active = false
        this.mode = null
        this.openerWinId = -1
        this.openerTabId = -1
        this.tabs = []
        this.replay = null
        this.removeListiners()
        browser.storage.local.remove(["ptk_replay_items", "ptk_replay_step", "ptk_replay"])
    }

    reset() {
        this.mode = null
        this.openerWinId = -1
        this.openerTabId = -1
        this.tabs = []
        this.replay = null
        this.recording = null
        this.bootstrap = null
        this.savedMacro = ""
        delete window.ptk_recorder_active
        browser.storage.local.remove(["ptk_recording", "ptk_recording_frames", "ptk_recording_items", "ptk_recording_timing"])
        this.removeListiners()
    }

    analyse() {
        let result = []
        let previousValue = []
        this.recording.recordingRequests.forEach(function (item) {

            let requestHeaders = item.requestHeaders ? item.requestHeaders : []
            let responseHeaders = item.responseHeaders ? item.responseHeaders : []
            let hostname = new URL(item.request.url).hostname

            if (!previousValue[hostname]) previousValue[hostname] = {}

            var resultitem = { hostname: hostname }
            requestHeaders.find(function (item) {
                if (item.name.toLowerCase() == 'cookie' && previousValue[hostname].cookie != item.value) {
                    resultitem.browser = { cookie: { item: {} } }
                    resultitem.browser.cookie = { item: item, request: item }
                    previousValue[hostname].cookie = item.value
                }
                if (item.name.toLowerCase() == 'authorization' && previousValue[hostname].authorization != item.value) {
                    resultitem.browser = { authorization: { item: {} } }
                    resultitem.browser.authorization = { item: item, request: item }
                    previousValue[hostname].authorization = item.value
                }
            })

            responseHeaders.find(function (item) {
                if (item.name.toLowerCase() == 'set-cookie') {
                    resultitem.server = { cookie: { item: {} } }
                    resultitem.server.cookie = { item: item, request: item }
                }
            })

            if (item.response?.body) {
                var body = item.response.base64Encoded ? atob(item.response.body) : item.response.body,
                    token = body.match(new RegExp('(?:"[^"]*token"\s?:\s?){1}"([A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*)"{1}'))
                if (token) {
                    resultitem.server = { token: { item: {} } }
                    resultitem.server.token = { item: token[token.length - 1], request: item }
                }
            }
            if (resultitem.browser || resultitem.server) {
                result.push(resultitem)
            }
        })
        return result
    }

}


