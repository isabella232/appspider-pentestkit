/* Author: Denis Podgurskii */
import { ptk_logger, ptk_notifications, ptk_utils } from "./utils.js"

export class ptk_recorder {
    constructor() {
        this.mode = null // recording || replay
        this.windId = 0
        this.tabId = 0
        this.recorderJS = "assets/js/content/recorder.js"
        this.recorderMainJS = "assets/js/content/recorderMain.js"


        this.replay = {
            replayStep: 0, replayEvents: [], enableRegex: false, validateRegex: null
        }

        this.recording = {
            startUrl: null, cleanCookie: false, items: [], requests: [], recordingRequests: [], tmpR: []
        }

        this.bootstrap = {
            bootstrapJobID: null, bootstrapEndpoint: null, bootstrapPutParams: null, bootstrapUsePut: false
        }

        this.savedMacro = ""
    }

    /* Listeners */

    addListiners() {
        this.onUpdated = this.onUpdated.bind(this)
        browser.tabs.onUpdated.addListener(this.onUpdated)

        this.onRemoved = this.onRemoved.bind(this)
        browser.tabs.onRemoved.addListener(this.onRemoved)

        this.onBeforeRequest = this.onBeforeRequest.bind(this)
        browser.webRequest.onBeforeRequest.addListener(this.onBeforeRequest,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["blocking", "requestBody"].concat(ptk_utils.extraInfoSpec)
        )

        this.onSendHeaders = this.onSendHeaders.bind(this)
        browser.webRequest.onSendHeaders.addListener(this.onSendHeaders,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["requestHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        this.onHeadersReceived = this.onHeadersReceived.bind(this)
        browser.webRequest.onHeadersReceived.addListener(this.onHeadersReceived,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        // this.onCompleted = this.onCompleted.bind(this)
        // browser.webRequest.onCompleted.addListener(this.onCompleted,
        //     { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
        //     ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        // )

    }

    removeListiners() {
        browser.tabs.onUpdated.removeListener(this.onUpdated)
        browser.tabs.onRemoved.removeListener(this.onRemoved)

        browser.webRequest.onBeforeRequest.removeListener(this.onBeforeRequest)
        browser.webRequest.onSendHeaders.removeListener(this.onSendHeaders)
        browser.webRequest.onHeadersReceived.removeListener(this.onHeadersReceived)
        //browser.webRequest.onCompleted.removeListener(this.onCompleted)
    }

    onUpdated(tabId, info, tab) {
        if (info.status != "complete") return

        if (this.mode == "recording" && tabId == this.tabId) {

            var self = this
            browser.tabs.executeScript(tabId, {
                file: self.recorderMainJS, matchAboutBlank: true, allFrames: false, runAt: "document_start"
            }).then(function (result) {
                browser.tabs.executeScript(tabId, {
                    file: self.recorderJS, matchAboutBlank: true, allFrames: true, runAt: "document_start"
                })
            })
        }
    }

    onRemoved(tabId, info) {
        if (this.mode == "recording" && tabId == this.tabId) {
            this.stop(info)
        }
    }

    onSendHeaders(request) {
        if (request.tabId == this.tabId) {
            let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, request.requestId)]
            if (r) r.requestHeaders = request.requestHeaders
        }
    }

    onHeadersReceived(response) {
        if (response.tabId == this.tabId) {
            let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, response.requestId)]
            if (r) {
                r.responseHeaders = response.responseHeaders
                r.response.statusCode = response.statusCode
                r.response.statusLine = response.statusLine
            }
        }
    }

    // onCompleted(response) {
    //     if (response.tabId == this.tabId) {
    //         let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, response.requestId)]
    //         if (r) {
    //             r.response.statusCode = response.statusCode
    //             r.response.statusLine = response.statusLine
    //         }
    //     }
    // }

    onBeforeRequest(request) {
        if (request.url.match(/(^wss:|-extension(s)?:)/) || request.type.match(/(ping)/)) return
        if (this.mode == "recording" && request.tabId == this.tabId) {
            try {
                var item = {
                    requestId: request.requestId, type: request.type, request: request, response: {}
                }

                this.recording.recordingRequests.push(item)

                if (window.ptk_app.isFirefox) {
                    let filter = browser.webRequest.filterResponseData(item.requestId)
                    let decoder = new TextDecoder("utf-8")

                    filter.ondata = (event => {
                        let str = decoder.decode(event.data, { stream: true })
                        filter.write(event.data)
                        filter.disconnect()
                        let r = this.recording.recordingRequests[this.findLastIndex(this.recording.recordingRequests, item.requestId)]
                        r.response.body = str
                        r.response.base64Encoded = false
                    }).bind(this)
                }
            }
            catch (e) { e => ptk_logger(e, "Could not update recording request", "warning") }
        }
    }

    onStart(win) {
        this.winId = win.id
        this.tabId = win.tabs[0].id
        if (!window.ptk_app.isFirefox) {
            //Attach debugger
            var version = "1.3";
            var debugTarget = { tabId: this.tabId };
            chrome.debugger.attach(debugTarget, version,
                this.onAttach()
            )
            chrome.debugger.sendCommand(debugTarget, "Network.setCacheDisabled", { cacheDisabled: true });
            chrome.debugger.sendCommand(debugTarget, "Network.enable");
        }
        browser.windows.update(win.id, { "focused": true });
        browser.tabs.update(this.tabId, { url: this.recording.startUrl });
    }

    findLastIndex(obj, requestId) {
        let l = obj.length
        while (l--) {
            if (obj[l].requestId == requestId) return l
        }
        return -1;
    }

    onAttach(tabId) {
        this.onEvent = this.onEvent.bind(this)
        chrome.debugger.onEvent.addListener(this.onEvent)
        this.onDetach = this.onDetach.bind(this)
        chrome.debugger.onDetach.addListener(this.onDetach)
    }

    onDetach(source, reason) {
        chrome.debugger.onEvent.removeListener(this.onEvent)
        chrome.debugger.onDetach.removeListener(this.onDetach)
    }

    onEvent(debuggeeId, message, params) {

        if (this.tabId != debuggeeId.tabId)
            return
        if (params.request && params.request.url && params.request.url.includes("-extension://"))
            return
        if (params.response && params.response.url && params.response.url.includes("-extension://"))
            return

        var item = {
            requestId: params.requestId,
            parentId: params.loaderId,
            type: params.type,
            response: {},
            timing: {}
        }
        var reverseIndex = this.findLastIndex(this.recording.requests, item.requestId)

        if (message == "Network.requestWillBeSent") {
            if (params.redirectResponse ||
                !this.recording.requests.some(e => e.requestId === params.requestId)) {
                item.request = params.request
                this.recording.requests.push(item)
            }
        }
        if (message == "Network.responseReceived" && reverseIndex > -1) {
            this.recording.requests[reverseIndex].timing = params.response.timing;
        }
        if (message == "Network.loadingFinished" && reverseIndex > -1) {
            chrome.debugger.sendCommand(debuggeeId, "Network.getResponseBody", { "requestId": params.requestId },
                function (response) {
                    this.recording.requests[reverseIndex].response.body = response.body
                    this.recording.requests[reverseIndex].response.base64Encoded = response.base64Encoded
                }.bind(this))

        }
    }

    /* End Listeners */




    cleanCookie(startUrl) {
        browser.cookies.getAll({ domain: (new URL(this.recording.startUrl)).hostname }).then(function (cookies) {
            var url = new URL(startUrl)
            for (var i = 0; i < cookies.length; i++) {
                browser.cookies.remove({
                    url: url.protocol + "//" + cookies[i].domain + cookies[i].path,
                    name: cookies[i].name
                })
            }
        })
    }

    start(cleanCookie, startUrl) {
        if (this.mode == null) {
            this.addListiners()
            this.recording = {
                startUrl: startUrl, cleanCookie: cleanCookie, items: [], requests: [], recordingRequests: []
            }
            this.mode = 'recording'

            if (this.recording.cleanCookie)
                this.cleanCookie(startUrl)
            
                browser.webRequest.handlerBehaviorChanged() //FF caching
            browser.storage.local.set({
                "ptk_recording_frames": [],
                "ptk_recording_items": [],
                "ptk_recording_timing": [],
                "ptk_recording_mode": this.mode,
                "ptk_recording": { mode: "recording", items: [], startUrl: this.recording.startUrl }
            }).then(function () {
                browser.windows.create({ url: 'about:blank', type: "popup" })
                    .then(
                        function (win) { this.onStart(win) }.bind(this))
            }.bind(this))

        } else {
            ptk_notifications.notify("Recording/playback already started", "Stop recording before start a new one");
        }
    }

    startMacro(cleanCookie, startUrl) {
        this.start(cleanCookie, startUrl)
    }

    stop(params) {
        this.mode = null
        this.windId = 0
        this.tabId = 0
        this.removeListiners()

        var a = JSON.parse(JSON.stringify(this.recording.requests))

        for (let l = 0; l < this.recording.recordingRequests.length; l++) {
            for (let k = 0; k < a.length; k++) {
                let r = a[k].request
                let u = r.urlFragment ? r.url + r.urlFragment : r.url
                if (this.recording.recordingRequests[l].request.url == u) {
                    this.recording.recordingRequests[l].response.body = a[k].response.body
                    this.recording.recordingRequests[l].response.base64Encoded = a[k].response.base64Encoded
                    this.recording.recordingRequests[l].timing = a[k].timing
                    a.splice(k, 1)
                    break
                }
            }
        }

        browser.storage.local.get(["ptk_recording_frames", "ptk_recording_items", "ptk_recording_timing"]).then(function (result) {
            console.log(result)
        }.bind(this))

        console.log(this.recording.requests)
        console.log(this.recording.recordingRequests)

    }

    reset(params) {

    }

}


