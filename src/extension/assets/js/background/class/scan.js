/* Author: Denis Podgurskii */
import { ptk_SqlInjection } from "../../../../../assets/js/modules/active/sqlInjection.js"
import { ptk_logger } from "../../../../../assets/js/background/class/utils.js"

export class ptk_scan {

    constructor(request) { 
        this.scanResult = []
        this.request = request
        this.attackModules = {
            SqlInjection: new ptk_SqlInjection()
        }
    }

    async runScan(schema) {
        this.scanResult = []
        for (let module in this.attackModules) {
            let module = this.attackModules[module]
            let moduleResult = []
            for (let attackIndex in module.attacks) {
                let attack = module.attacks[attackIndex]
                if (attack.location.includes('Post')) {
                    let modifiedSchema = JSON.parse(JSON.stringify(schema))
                    modifiedSchema.toString = schema.toString
                    let params = modifiedSchema.request.body.split('&')
                    for (let i in params) {
                        params[i] = attack.position == 'before' ? params[i].replace('=', '=' + attack.attackValue) : params[i] + attack.attackValue
                    }
                    modifiedSchema.request.body = params.join('&')
                    await new Promise((resolve) => {
                        setTimeout(() => {
                            // Resolve the promise
                            resolve(this.runPostAttack(modifiedSchema, attack, module.vulnRegex))
                        }, 500)
                    })
                }
            }
        }
    }

    runPostAttack(schema, attack, vulnRegex) {

        this.request.sendRequest(schema).then((result) => {
            let body = result.body
            let re = new RegExp(vulnRegex)
            let item = {}
            item = {
                attack: attack,
                request: schema.toString(),
                baseUrl: schema.request.url,
                response: btoa(body)
            }

            if (re.test(body)) {
                item.success = true
                item.proof = body.match(re)
                this.scanResult.push(item)
                console.log("match found")
            } else {
                item.success = false
                item.proof = ""
                this.scanResult.push(item)
                console.log("match NOT found")
            }
            browser.runtime.sendMessage({
                channel: "ptk_background2popup_scan",
                type: "attack completed",
                info: item
            }).catch(e => ptk_logger(e, "Could not send a message", "info"))
        }).catch(function (error) {
            $form.form('set value', 'response_headers', error.message)
            ptk_logger(e, "Could not run an attack", "info")
        })
    }

}
