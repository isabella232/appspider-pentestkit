/* Author: Denis Podgurskii */
import { ptk_SqlInjection } from "../../../../../assets/js/modules/active/sqlInjection.js"
import { ptk_logger } from "../../../../../assets/js/background/class/utils.js"

export class ptk_scan {

    constructor(request) { 
        this.scanResult = []
        this.request = request
        this.attackModules = {
            SqlInjection: new ptk_SqlInjection()
        }
    }

    async runScan(schema) {
        this.scanResult = []
        for (var module in this.attackModules) {
            var module = this.attackModules[module]
            var moduleResult = []
            for (var attackIndex in module.attacks) {
                var attack = module.attacks[attackIndex]
                if (attack.location.includes('Post')) {
                    var modifiedSchema = JSON.parse(JSON.stringify(schema))
                    modifiedSchema.toString = schema.toString
                    var params = modifiedSchema.request.body.split('&')
                    for (var i in params) {
                        params[i] = attack.position == 'before' ? params[i].replace('=', '=' + attack.attackValue) : params[i] + attack.attackValue
                    }
                    modifiedSchema.request.body = params.join('&')
                    await new Promise((resolve) => {
                        setTimeout(() => {
                            // Resolve the promise
                            resolve(this.runPostAttack(modifiedSchema, attack, module.vulnRegex))
                        }, 500)
                    })
                }
            }
        }
    }

    runPostAttack(schema, attack, vulnRegex) {

        this.request.sendRequest(schema).then((result) => {
            let body = result.body
            var re = new RegExp(vulnRegex)
            var item = {}
            item = {
                attack: attack,
                request: schema.toString(),
                baseUrl: schema.request.url,
                response: btoa(body)
            }

            if (re.test(body)) {
                item.success = true
                item.proof = body.match(re)
                this.scanResult.push(item)
                console.log("match found")
            } else {
                item.success = false
                item.proof = ""
                this.scanResult.push(item)
                console.log("match NOT found")
            }
            browser.runtime.sendMessage({
                channel: "ptkBackgroundToPopup",
                type: "attack completed",
                info: item
            }).catch(e => ptk_logger(e, "Could not send a message", "info"))
        }).catch(function (error) {
            $form.form('set value', 'response_headers', error.message)
            ptk_logger(e, "Could not run an attack", "info")
        })


        // var x_pentestkitHeaders = btoa(JSON.stringify(schema.request.headers.map(x => {
        //     var h = x.split(':')
        //     if (h.length > 2) return { name: h.shift(), value: h.join(":") }
        //     return { name: h[0], value: h[1] }
        // })))

        // var rHeaders = new Headers(schema.request.headers.map(x => {
        //     var h = x.split(':')
        //     if (h.length > 2) return [h.shift(), h.join(":")]
        //     return h
        // }))
        // rHeaders.append('x-penetrationtestingkitheaders', x_pentestkitHeaders)

        // var params = {
        //     method: schema.request.method,
        //     mode: 'cors',
        //     redirect: "follow",
        //     credentials: 'same-origin',
        //     cache: 'no-cache',
        //     headers: rHeaders
        // }
        // if (schema.request.body && !schema.request.method.toUpperCase().match(/(^GET|^HEAD)/)) {
        //     params.body = schema.request.body

        // }
        // var request = new Request(schema.request.url, params)

        // fetch(request)
        //     .then((response) => response.text())
        //     .then((body) => {
        //         var re = new RegExp(vulnRegex)
        //         var item = {}
        //         item = {
        //             attack: attack,
        //             request: schema.toString(),
        //             baseUrl: schema.request.url,
        //             response: btoa(body)
        //         }

        //         if (re.test(body)) {
        //             item.success = true
        //             item.proof = body.match(re)
        //             this.scanResult.push(item)
        //             console.log("match found")
        //         } else {
        //             item.success = false
        //             item.proof = ""
        //             this.scanResult.push(item)
        //             console.log("match NOT found")
        //         }
        //         browser.runtime.sendMessage({
        //             channel: "ptkBackgroundToPopup",
        //             type: "attack completed",
        //             info: item
        //         }).catch(e => ptk_logger(e, "Could not send a message", "info"))
        //     })
    }

}
