/* Author: Denis Podgurskii */

import { ptk_utils } from "./utils.js"

export class ptk_settings {
    constructor() {
        this.reset()
        this.addMessageListeners()
    }

    reset() {
        this.main = {
            general: {
                enable_logging: false,
                enable_appspider: false,
                enable_websocket: false,
                max_tabs: 5,
                max_requests_per_tab: 50,
                tabs_capturing: true
            },
            proxy: {
                pac_protocol: "http://",
                pac_path: "",

                http_url: "",
                http_port: "",
                https_url: "",
                https_port: "",
                socks_url: "",
                socks_port: "",
                socks_type: 'socks5',

                username: "",
                password: "",

                bypass: '127.0.0.1/*, 192,168.0.1/*'
            },
            headers: {
                protocol: "HTTP/1.1",
                useragent: "Mozilla/5.0 (X11 Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 OPR/38.0.2220.41",
                accept: "*/*",
                acceptcharset: "utf-8, iso-8859-1q=0.5, *q=0.1",
                acceptlanguage: "en-US,enq=0.5",
                acceptencoding: "deflate, gzipq=1.0, *q=0.5",
                extraheaders: "",
                cookie: ""
            }
        }

        //Request builder settings
        this.requestbuilder = {
            proxy: {},
            headers: {}
        }

        //Headers page
        this.headers = {
            request: {},
            response: {}
        }

        //Macro page
        this.macro = {
            format: "xml", // [xml, side, html]
            min_duration: 3000,
            element_path: "id", //[id, fullpath]
            event_type: "javascript", //[javascript, driverclick, onclick ]
            enable_regex: false,
            validate_regex: "(sign|log)[ -]?(out|off)"
        }

        this.traffic = {
            format: "har"
        }

        this.integration = {
            enable: true,
            content_script: "/assets/js/content/integration.js",
            channel: "ptk_messages_channel"
        }

        this.rattacker = {
            enable: true
        }

        this.tabs = {
            enable: true
        }
    }

    /* Listeners */
    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_settings") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_update_settings(message) {
        return this.updateSettings(message.path, message.value).then(function () {
            return Promise.resolve({ settings: JSON.parse(JSON.stringify(this)) })
        }.bind(this))
    }

    msg_reset_settings(message) {
        return this.resetSettings().then(function () {
            return Promise.resolve({ settings: JSON.parse(JSON.stringify(this)) })
        }.bind(this))
    }

    msg_get_settings(message) {
        return this.getSettings(message.path)
    }

    /* End Listeners */


    async updateSettings(path, value) {
        ptk_utils.jsonSetValueByPath(this, path, value)
        return browser.storage.local.set({ "pentestkit_settings": JSON.parse(JSON.stringify(this)) })
    }

    async getSettings(path) {
        let result = this
        if (path) result = ptk_utils.jsonGetValueByPath(this, path)
        return Promise.resolve(result)
    }

    async resetSettings() {
        this.reset()
        return browser.storage.local.set({ "pentestkit_settings": JSON.parse(JSON.stringify(this)) })
    }

    mergeSettings(source) {
        if (!source) return this
        return this.deepMerge(this, source)
    }

    deepMerge(target, source) {
        if (!source) return target
        for (const key in source) {
            if (target.hasOwnProperty(key)) {
                if (typeof (source[key]) === 'object') {
                    this.deepMerge(target[key], source[key])
                } else {
                    Object.assign(target, { [key]: source[key] })
                }
            }
        }
        return target
    }

}