/* Author: Denis Podgurskii */
import { ptk_logger, ptk_utils } from "./utils.js"

export class ptk_request {

    constructor() {
        this.trackingRequest = new Map()
        this.originalHeaders = null

        this.addMessageListeners()
    }

    /* Listeners */

    addListeners() {

        this.onBeforeSendHeaders = this.onBeforeSendHeaders.bind(this)
        browser.webRequest.onBeforeSendHeaders.addListener(
            this.onBeforeSendHeaders,
            { urls: ["<all_urls>"], types: ptk_utils.filterType },
            ["blocking", "requestHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        this.onHeadersReceived = this.onHeadersReceived.bind(this);
        browser.webRequest.onHeadersReceived.addListener(
            this.onHeadersReceived,
            { urls: ["<all_urls>"], types: ptk_utils.filterType },
            ["blocking", "responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
    }

    removeListeners() {
        console.log('REMOVE LIST')
        browser.webRequest.onBeforeSendHeaders.removeListener(this.onBeforeSendHeaders)
        browser.webRequest.onHeadersReceived.removeListener(this.onHeadersReceived)
    }

    onBeforeSendHeaders(request) {
        if (this.originalHeaders) {
            this.trackingRequest.set(request.requestId, {})
            let headers = this.originalHeaders
            this.originalHeaders = null
            return { requestHeaders: headers }
        } else if(this.trackingRequest.has(request.requestId)){
            console.log('ddd')
        }
        return { requestHeaders: request.requestHeaders }
    }

    onHeadersReceived(response) {
        if (this.trackingRequest.has(response.requestId)) {
            this.trackingRequest.get(response.requestId).statusLine = response.statusLine
            this.trackingRequest.get(response.requestId).headers = response.responseHeaders
        }
        return { responseHeaders: response.responseHeaders }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_request") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    msg_parse_request(message) {
        let schema = this.parseRawRequest(message.item)
        schema.request.asString = schema.toString()
        return Promise.resolve(JSON.parse(JSON.stringify(schema)))
    }

    msg_update_request(message) {
        let schema = this.updateRawRequest(message.item)
        schema.request.asString = schema.toString()
        return Promise.resolve(JSON.parse(JSON.stringify(schema)))
    }

    msg_send_request(message) {
        return this.sendRequest(message.schema).then(function (response) {
            return Promise.resolve(response)
        })
    }

    /* End Listeners */

    validate = function (message) {
        if (message && message.function == 'validate') {
            browser.windows.create({
                url: browser.extension.getURL("browser/requestbuilder.html?validateRequest=" + message.parameters),
                type: "popup",
                'width': 1200,
                'height': 700
            })
        }
    }

    updateRawRequest(requestObject) {

        if (!requestObject.request_url.startsWith(requestObject.request_protocol + "://"))
            requestObject.request_url = requestObject.request_protocol + "://" + requestObject.request_url.replace(/^https?:\/\//, '')

        if (requestObject.request.trim() == "") {
            requestObject.request = requestObject.request_method + " " + requestObject.request_url + " HTTP/1.1"
        } else {
            let requestData = requestObject.request.trim().split(/\r?\n/)
            requestData[0] = requestObject.request_method + " " + requestObject.request_url + " HTTP/1.1"
            requestObject.request = requestData.join('\n')
        }
        let schema = this.parseRawRequest(requestObject)

        return schema
    }

    parseRawRequest(requestObject) {
        console.log(requestObject)
        let schema = this.requestSchema()
        let requestData = requestObject.request.trim().split(/\n\n/)
        let headerArray = requestData[0].split(/\r?\n/)

        let host = null
        if (headerArray.filter(x => x.includes('Host:')).length != 0) {
            let h = headerArray.filter(x => x.includes('Host:'))[0].split(":")
            h.shift()
            host = h.join(":").trim()
        }

        let requestString = headerArray.shift()
        if (requestString.toUpperCase().match(/(^GET|^POST|^HEAD|^PUT|^DELETE|^OPTIONS)/)) {
            let requestArray = requestString.split(' ')
            console.log(requestArray)
            if (requestArray[1].startsWith('http') && requestArray[1].trim() != "http://" && requestArray[1].trim() != "https://") {
                schema.request.url = new URL(requestArray[1])
                //Add Host header if doesn't exist
                if (headerArray.filter(x => x.includes('Host:')).length == 0) {
                    headerArray.push('Host: ' + schema.request.url.host)
                } else {
                    headerArray[headerArray.findIndex(x => x.includes('Host:'))] = 'Host: ' + schema.request.url.host
                }
            } else {
                if (!host)
                    throw 'Host value not defined. Use an absolute URL or add "Host" header.'
                let baseUrl = requestObject.request_protocol + "://" + host
                schema.request.url = new URL(requestArray[1], baseUrl)
            }
            schema.request.method = requestArray[0].trim()
            schema.request.version = requestArray[2]
            schema.request.protocol = schema.request.url.protocol
            schema.request.host = schema.request.url.host
        }

        schema.request.headers = headerArray;
        if (requestData.length > 1 && schema.request.method != 'GET' && schema.request.method != 'HEAD') {
            schema.request.body = requestData[1]
        }
        return schema
    }

    sendRequest(schema) {

        this.addListeners()
        this.trackingRequest = new Map()
        this.originalHeaders = schema.request.headers.map(x => {
            let h = x.split(':')
            if (h.length > 2) return { name: h.shift(), value: h.join(":") }
            return { name: h[0], value: h[1] }
        })

        let rHeaders = new Headers(schema.request.headers.map(x => {
            let h = x.split(':')
            if (h.length > 2) return [h.shift(), h.join(":")]
            return h
        }))

        let params = {
            method: schema.request.method,
            mode: 'cors',
            redirect: schema.request.followRedirect ? "follow" : "manual",
            credentials: 'include',
            cache: 'no-cache',
            headers: rHeaders
        }
        if (schema.request.body && !schema.request.method.toUpperCase().match(/(^GET|^HEAD)/)) {
            params.body = schema.request.body
        }
        let request = new Request(schema.request.url, params)

        return fetch(request).then(function (response) {
            this.removeListeners()

            let pentestkitRequest = {}
            for (let value of this.trackingRequest.values()) {
                pentestkitRequest = value
            }

            let headers = pentestkitRequest.statusLine + "\n"
            pentestkitRequest.headers.forEach(function (h, key) {
                headers += (h.name != "" ? h.name + ": " : "") + h.value + "\r\n"
            })

            return response.text().then(function (body) {
                return { headers: headers, body: body }
            })
        }.bind(this)).catch(e => console.log(e))

    }

    requestSchema() {
        return {
            request: {
                method: '',
                headers: [],
                cookie: [],
                body: '',
                version: '',
                url: null,
                host: null,
                protocol: null,
                followRedirect: true
            },
            response: {
                headers: [],
                content: ''
            },
            toString: function () {
                let r = this.request.method + ' ' + this.request.url + ' ' + this.request.version + '\n' + this.request.headers.join('\n')
                if (this.request.body) r += '\n\n' + this.request.body
                return r
            }
        }
    }

}