/* Author: Denis Podgurskii */
'use strict';
////////////////////////////////////
/* Tab */
////////////////////////////////////
/*
{frames: new Map[ frameId: new Map [requestId: [item: {request: object, response: object} ] ] ] }
*/

function Tab(tabId, params, type) {
    this.setParams = function (params, type) {
        if (Number.isInteger(params.frameId)) {
            //Init frame map if doesn't exist
            if (!this.frames.has(params.frameId)) {
                this.frames.set(params.frameId, new Map());
                BackgroundProxy.Logger.log("Init frames", { frameId: params.frameId, requestId: params.requestId });
            }
            //Init request map if doesn't exist
            if (!this.frames.get(params.frameId).has(params.requestId)) {
                this.frames.get(params.frameId).set(params.requestId, new Array());
            }
            var index = this.frames.get(params.frameId).get(params.requestId).length;
            if (type == 'start') {
                this.frames.get(params.frameId).get(params.requestId).push(params);
                BackgroundProxy.Logger.log("Add new item for ", { frameId: params.frameId, requestId: params.requestId });
            } else {
                for (var p in params) {
                    if (this.frames.get(params.frameId).get(params.requestId)[index - 1][p] != params[p]) {
                        this.frames.get(params.frameId).get(params.requestId)[index - 1][p] = params[p];
                    }
                }
                BackgroundProxy.Logger.log("Updated params ", { params: params, frameId: params.frameId, requestId: params.requestId });
            }
        } else {
            for (var p in params) {
                this[p] = params[p];
                BackgroundProxy.Logger.log("Add or update param ", { p: params[p] });
            }
        }
    };

    this.reduceSize = function (maxRequest) {
        this.frames.forEach((frame, fkey) => {
            frame.forEach((request, rkey) => {
                if (frame.size >= maxRequest) {
                    frame.delete(rkey);
                }
            });
        });
    };

    this.tabId = tabId;
    this.frames = new Map();
    this.setParams(params, type);
}; //end Tab

////////////////////////////////////
/* Settings */
////////////////////////////////////

function Settings() {
    return {
        //Index page
        main: {
            general: {
                capture_all_requests: false,
                capture_responses: false,
                enable_logging: false,
                max_requests_per_tab: 50,
                enable_appspider: false,
                enable_websocket: false
            },
            proxy: {
                pac_protocol: "http://",
                pac_path: "",

                http_url: "",
                http_port: "",
                https_url: "",
                https_port: "",
                socks_url: "",
                socks_port: "",
                socks_type: 'socks5',

                username: "",
                password: "",

                bypass: '127.0.0.1/*, 192,168.0.1/*'
            },
            headers: {
                protocol: "HTTP/1.1",
                useragent: "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 OPR/38.0.2220.41",
                accept: "*/*",
                acceptcharset: "utf-8, iso-8859-1;q=0.5, *;q=0.1",
                acceptlanguage: "en-US,en;q=0.5",
                acceptencoding: "deflate, gzip;q=1.0, *;q=0.5",
                extraheaders: "",
                cookie: ""
            }
        },
        //Request builder settings
        requestbuilder: {
            proxy: {},
            headers: {}
        },
        //Headers page
        headers: {
            request: {},
            response: {}
        }
    };
}; //end Settings

////////////////////////////////////
/* Request */
////////////////////////////////////

function Request() {
    this.validate = function (message) {
        if (message && message.function == 'validate') {
            chrome.windows.create({
                url: chrome.extension.getURL("browser/requestbuilder.html?validateRequest=" + message.parameters),
                type: "popup",
                'width': 1200,
                'height': 700
            },
                function (win) {
                    BackgroundProxy.excludeTab(win.tabs[0].id);
                });
        }
    };

    this.parseRequestString = function (requestStr, requestObject) {

        /* Start */
        var schema = this.schema();

        var requestData = requestStr.trim().split(/\n\n/);
        var headerArray = requestData[0].split(/\r?\n/);

        var headers = [];
        for (var i = 0; i < headerArray.length; i++) {
            if (headerArray[i].toUpperCase().match(/(^GET|^POST|^HEAD|^PUT|^DELETE|^OPTIONS)/)) {
                var requestArray = headerArray[i].split(' ');
                schema.uri = this.parseUri(schema.uri, requestArray[1]);
                schema.request.method = requestArray[0].trim();
                schema.request.version = requestArray[2];
            } else if (headerArray[i].indexOf(':') > -1) {
                var a = headerArray[i].split(':');
                var header_name = a[0].trim();
                switch (header_name.toLowerCase()) {
                    case 'cookie':
                        var cookiearray = a[a.length - 1].split(';');
                        var cookies = [];
                        for (var x = 0; x < cookiearray.length; x++) {
                            if (cookiearray[x].indexOf('=') > -1) {
                                var array = cookiearray[x].split('=');
                                var key = array[0].trim();
                                var value = array[array.length - 1].trim();
                                cookies.push({
                                    name: key,
                                    value: value
                                });
                            }
                        }
                        headers.push({ name: header_name, value: a.slice(1).join(':').trim() });
                        schema.request.cookie = cookies;
                        break;
                    case 'host':
                        if (a.length == 3) {
                            schema.uri.port = a[a.length - 1].trim();
                            schema.uri.url = a[a.length - 2].trim()
                        } else if (a.length == 2) {
                            schema.uri.url = a[a.length - 1].trim()
                        }
                        var h = parseInt(schema.uri.port) > 0 ? schema.uri.url + ":" + schema.uri.port : schema.uri.url;
                        headers.push({ name: header_name, value: h });
                        schema.request.host = h;
                        break;
                    default:
                        headers.push({ name: header_name, value: a.slice(1).join(':').trim() });
                        break;
                }
            }
        }
        schema.request.headers = headers;
        if (requestObject) {
            schema.request.method = requestObject.request_method;
            schema.uri.protocol = requestObject.request_protocol;
            schema.uri.url = requestObject.request_url;
            schema.uri.port = requestObject.request_port;
        }
        if (requestData.length > 1 && schema.request.method != 'GET' && schema.request.method != 'HEAD') {
            BackgroundProxy.Logger.log(requestData);
            schema.request.body = requestData[1];
        }
        var url = schema.uri.path;
        if(!schema.uri.path.startsWith('http://') && !schema.uri.path.startsWith('https://'))
            url = schema.uri.protocol + '://' + schema.uri.url + ((schema.uri.port != "80" && schema.uri.port != "443") ? (":" + schema.uri.port) : "") + schema.uri.path;
        if (schema.uri.queryString) url += schema.uri.queryString;
        schema.request.url = url;
        /* End */
        return schema;
    };

    this.parseAttackResponse = function (responseSchema, xhr) {
        var headerString = xhr.getAllResponseHeaders();
        var headerArray = headerString.split('\r\n');
        var headers = [];
        var content = xhr.responseText;
        BackgroundProxy.Logger.log(xhr);
        for (var i = 0; i < headerArray.length; i++) {
            var a = headerArray[i].split(':');
            if (a[0].trim() !== '') {
                headers.push({
                    name: a[0].trim(),
                    value: a[1].trim()
                });
            }
        }
        responseSchema.headers = headers;
        responseSchema.content = content;
        return responseSchema;
    };

    this.parseUri = function (uriSchema, unparsedUri) {
        if (unparsedUri.indexOf('?') > 0) {
            uriSchema.path = unparsedUri.substring(0, unparsedUri.indexOf('?'));
            uriSchema.parameters = this.parseQueryString(unparsedUri.substring(unparsedUri.indexOf('?') + 1));
            uriSchema.queryString = unparsedUri.substring(unparsedUri.indexOf('?'));
        } else {
            uriSchema.parameters = [];
            uriSchema.path = unparsedUri;
        }
        return uriSchema;
    };

    this.parseQueryString = function (queryString) {
        if (queryString.indexOf('?') === 0) {
            queryString = queryString.slice(1);
        }
        var parameters = [];
        var queryArray = queryString.split('&');
        for (var index in queryArray) {
            if (queryArray.hasOwnProperty(index)) {
                parameters.push({
                    key: queryArray[index].split('=')[0],
                    value: queryArray[index].split('=')[1]
                });
            }
        }
        return parameters;
    };

    this.schema = function () {
        return {
            request: function () {
                return {
                    headers: [],
                    body: '',
                    cookie: [],
                    uri: this.schema.uri(),
                    method: '',
                    version: '',
                    host: '',
                    url: ''
                }
            },
            response: function () {
                return {
                    headers: 'Waiting for attack response....(click the ' +
                        'Send request button if response is taking a while)',
                    content: ''
                }
            },
            uri: function () {
                return {
                    parameters: [],
                    protocol: 'http',
                    url: '',
                    path: '',
                    queryString: '',
                    port: ''
                }
            }
        }
    };
}; //end Request


////////////////////////////////////
/* Utils */
////////////////////////////////////

function Utils() {
    this.jsonPathToValue = function (jsonData, path) {
        if (!(jsonData instanceof Object) || typeof (path) === "undefined") {
            throw "Not valid argument:jsonData:" + jsonData + ", path:" + path;
        }
        path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        path = path.replace(/^\./, ''); // strip a leading dot
        var pathArray = path.split('.');
        for (var i = 0, n = pathArray.length; i < n; ++i) {
            var key = pathArray[i];
            if (key in jsonData) {
                if (jsonData[key] !== null) {
                    jsonData = jsonData[key];
                } else {
                    return null;
                }
            } else {
                return key;
            }
        }
        return jsonData;
    };

    this.jsonSetValueByPath = function (jsonData, path, value) {
        if (!(jsonData instanceof Object) || typeof (path) === "undefined") {
            throw "Not valid argument:jsonData:" + jsonData + ", path:" + path;
        }
        var origData = jsonData;
        path = path.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
        path = path.replace(/^\./, ''); // strip a leading dot
        var pathArray = path.split('.');
        var i = 0;
        do {
            var key = pathArray[i];
            if (key in jsonData) {
                if (i < (pathArray.length - 1))
                    jsonData = jsonData[key];
                else
                    jsonData[key] = value;

            }
            i++;
        } while (i < pathArray.length)
        return origData;
    };
}; //end Utils

////////////////////////////////////
/* Logger */
////////////////////////////////////

function Logger() {
    this.log = function (event, msg, level) {
        if (BackgroundProxy.settings != null && BackgroundProxy.settings.main.general.enable_logging) {
            console.log("---------" + event + "---------");
            if (msg instanceof Array) {
                for (m in msg) {
                    console.log(m + ": " + msg[m]);
                }
            } else console.log(msg);
            console.log("Logged at: " + Date.now());
        }
    };

}; //end Logger


////////////////////////////////////
/* XHeaders */
////////////////////////////////////
/*
{request: [ {header_name: "", header_value: "", matchstring: "", operation: "equals", part: "url", type: "add"} ] ,
 response:  [ {header_name: "", header_value: "", matchstring: "", operation: "equals", part: "url", type: "add"} ]}
*/
function eXHeaders() {
    this.headers = [];
    this.add = function (type, obj) {

        chrome.storage.local.get('pentestkit_headers', function (result) {
            var arHeaders = { request: [], response: [] };
            if (result.pentestkit_headers) {
                arHeaders = result.pentestkit_headers;
            }
            if (type == 'request') {
                arHeaders.request[arHeaders.request.length] = obj;
            } else {
                arHeaders.response[arHeaders.response.length] = obj;
            }
            BackgroundProxy.eXHeaders.headers = arHeaders;
            chrome.storage.local.set({ 'pentestkit_headers': arHeaders });
        });

    };

    this.clean = function (item) {
        chrome.storage.local.get('pentestkit_headers', function (result) {
            var arHeaders = { request: [], response: [] };
            if (result.pentestkit_headers) {
                arHeaders = result.pentestkit_headers;
            }
            if (item.type == 'request') {
                arHeaders.request = [];
            } else {
                arHeaders.response = [];
            }
            BackgroundProxy.eXHeaders.headers = arHeaders;
            chrome.storage.local.set({ 'pentestkit_headers': arHeaders });
        });
    };

    this.remove = function (item) {
        chrome.storage.local.get('pentestkit_headers', function (result) {
            if (!result.pentestkit_headers) return;
            if (item.type == 'request') {
                result.pentestkit_headers.request.splice(item.index, 1);
            } else {
                result.pentestkit_headers.response.splice(item.index);
            }
            BackgroundProxy.eXHeaders.headers = result.pentestkit_headers;
            chrome.storage.local.set({ 'pentestkit_headers': result.pentestkit_headers });
        });
    };

    this.getHeaders = function () {
        return BackgroundProxy.eXHeaders.headers;
    };

}; //end XHeaders



////////////////////////////////////
/* Recorder */
////////////////////////////////////

function Recorder() {
    this.replay_step = 0;
    this.replayEvents = [];
    this.mode = null; // recording || replay
    this.validateRegex = null;
    this.recorderJS = "assets/js/recorder.js";
    this.tabId = null;
    this.openerTabId = null;
    this.items = [];
    this.startUrl = null;
    this.minDuration = 8000;
    this.elementPath = "id"; // fullpath
    this.useJavascript = false; 
    this.enableRegex = false; 
    this.playbackRegex = ""; 
    //traffic recording
    this.requests = [];
    this.captureNetwork = false;
    this.cleanCookie = false;
    this.bgRequests = [];
    //bootstrap
    this.bootstrapJobID = null;
    this.bootstrapEndpoint = null;
    this.bootstrapPutParams = null;
    this.bootstrapUsePut = false;

    this.savedMacro = "";


    this.start = function (data) {
        if (this.mode == null) {

            this.items = [];
            this.requests = [];
            this.bgRequests = [];
            this.startUrl = data.start_url
            this.mode = 'recording';

            var domain = (new URL(this.startUrl)).hostname;
            if (this.cleanCookie) {
                chrome.cookies.getAll({ domain: domain }, function (cookies) {
                    var url = new URL(BackgroundProxy.Recorder.startUrl);
                    for (var i = 0; i < cookies.length; i++) {
                        chrome.cookies.remove({
                            url: url.protocol + "//" + cookies[i].domain + cookies[i].path,
                            name: cookies[i].name
                        });
                    }
                });
            }
            setTimeout(function () {
                chrome.windows.create({ url: 'about:blank', type: "popup", incognito: data.incognito },
                    function (win) {
                        BackgroundProxy.Recorder.tabId = win.tabs[0].id;
                        if (BackgroundProxy.Recorder.captureNetwork) {
                            //Attach debugger
                            var version = "1.3";
                            var debugTarget = { tabId: BackgroundProxy.Recorder.tabId };
                            chrome.debugger.attach(debugTarget, version,
                                BackgroundProxy.Recorder.onAttach(null, BackgroundProxy.Recorder.tabId)
                            );
                            chrome.debugger.sendCommand(debugTarget, "Network.setCacheDisabled", { cacheDisabled: true });
                            chrome.debugger.sendCommand(debugTarget, "Network.enable");
                        }
                        //should be an alert, so a user can confirm start recording
                        alert("You are now recording a macro/traffic sequence");
                        chrome.windows.update(win.id, { "focused": true });
                        chrome.tabs.update(BackgroundProxy.Recorder.tabId, {url: BackgroundProxy.Recorder.startUrl});
                    });
            }, 100);

        } else {
            BackgroundProxy.Notifications.notify("Recording/playback already started", "Stop recording before start a new one");
        }
    };

    this.startMacro = function (data) {
        this.captureNetwork = true;
        this.start(data);
    };

    this.startTraffic = function (data) {
        this.captureNetwork = true;
        this.start(data);
    };

    this.startBootstrap = function (data) {
        this.cleanCookie = true;
        this.captureNetwork = true;
        this.bootstrapJobID = data.jobID;
        this.bootstrapEndpoint = data.restAPI;
        this.bootstrapPutParams = data.putParams ? data.putParams : null;
        this.bootstrapUsePut = data.usePut ? data.usePut : false;
        this.start(data);
    };

    this.append = function (data) {
        this.items = data.items;
    };

    this.reset = function () {
        this.items = [];
        this.requests = [];
        this.bgRequests = [];
        this.replayEvents = [];
        this.validateRegex = null;

        this.cleanCookie = false;
        this.startUrl = null;

        this.replay_step = 0;
        this.mode = null;
        this.captureNetwork = false;
        this.openerTabId = null;

        this.bootstrapJobID = null;
        this.bootstrapEndpoint = null;
        this.bootstrapPutParams = null;
        this.bootstrapUsePut = false;

        this.minDuration = 8000;
        this.elementPath = "id";
        this.useJavascript = false; 
        this.enableRegex = false; 
        this.playbackRegex = ""; 

        this.savedMacro = "";
    };

    this.stop = function (removeInfo) {

        if (this.cleanCookie && this.startUrl != null) {
            var domain = (new URL(this.startUrl)).hostname;
            chrome.cookies.getAll({ domain: domain }, function (cookies) {
                var url = new URL(BackgroundProxy.Recorder.startUrl);
                for (var i = 0; i < cookies.length; i++) {
                    chrome.cookies.remove({
                        url: url.protocol + "//" + cookies[i].domain + cookies[i].path,
                        name: cookies[i].name
                    });
                }
                BackgroundProxy.Recorder.cleanCookie = false;
                BackgroundProxy.Recorder.startUrl = null;
            });
        }

        try {
            if (removeInfo == null && BackgroundProxy.Recorder.tabId != null) {
                chrome.tabs.get(BackgroundProxy.Recorder.tabId, function (tab) {
                    if (tab && tab.id) chrome.tabs.remove(tab.id);
                });
            }
        } catch (e) { }

        this.replayEvents = [];
        this.validateRegex = null;
        this.tabId = null;
        this.replay_step = 0;
        this.mode = null;
        this.captureNetwork = false;

        chrome.runtime.sendMessage({
            channel: "ptkBackgroundToPopup",
            type: "recording completed"
        });
    };


    this.updateTab = function (data) {
        var recorder = BackgroundProxy.Recorder;
        switch (recorder.mode) {

            case 'replay':
                var event = recorder.replayEvents[recorder.replay_step];
                if (recorder.replay_step > recorder.replayEvents.length) return;

                if (event) {
                    setTimeout(BackgroundProxy.Recorder.updateTab, event.Duration, event);
                    chrome.tabs.sendMessage(BackgroundProxy.Recorder.tabId, {
                        channel: 'ptkBackgroundToRecorder',
                        action: "replay",
                        event: event
                    });
                    BackgroundProxy.Notifications.notify("Macro playback", "Execute event: " + event.EventType);
                } else {
                    if (recorder.validateRegex != null) {
                        chrome.tabs.sendMessage(BackgroundProxy.Recorder.tabId, {
                            channel: 'ptkBackgroundToRecorder',
                            action: "validateRegex",
                            regex: recorder.validateRegex
                        });
                    }
                    setTimeout(BackgroundProxy.Recorder.stop, 3500, null);
                }

                recorder.replay_step++;
                break;

            case 'recording':
                if (recorder.items.length > 0) {
                    chrome.tabs.sendMessage(recorder.tabId, {
                        channel: 'ptkBackgroundToRecorder',
                        action: "initRecorder",
                        items: recorder.items
                    });
                } else if (recorder.startUrl != null) {
                    chrome.tabs.sendMessage(recorder.tabId, {
                        channel: 'ptkBackgroundToRecorder',
                        action: "openRecorderURL",
                        url: recorder.startUrl
                    });
                }
                break;

            default:
                break;
        }
    };

    this.replay = function (data) {
        if (this.mode == null) {
            this.replayEvents = data.events;
            this.mode = 'replay';
            this.replay_step = 1;
            this.validateRegex = data.validateRegex;

            setTimeout(function () {
                chrome.windows.create({ url: data.url, type: "popup" },
                    function (win) {
                        BackgroundProxy.Recorder.tabId = win.tabs[0].id;
                        alert("You are now starting a macro playback");
                        chrome.windows.update(win.id, { "focused": true });
                        BackgroundProxy.Notifications.notify("Macro playback", "Execute event: Navigate");
                    });
            }, 100);
        } else {
            BackgroundProxy.Notifications.notify("Recording/playback already started", "Stop playback/recording before start a new one");
        }
    };

    this.onAttach = function (tabId) {
        if (chrome.runtime.lastError) {
            alert(chrome.runtime.lastError.message);
            return;
        }
        chrome.debugger.onEvent.addListener(BackgroundProxy.Recorder.onEvent);
        chrome.debugger.onDetach.addListener(BackgroundProxy.Recorder.onDetach);
    };

    this.onDetach = function () {
        chrome.debugger.onEvent.removeListener(BackgroundProxy.Recorder.onEvent);
        chrome.debugger.onDetach.removeListener(BackgroundProxy.Recorder.onDetach);
    };

    this.onEvent = function (debuggeeId, message, params) {

        if (BackgroundProxy.Recorder.tabId != debuggeeId.tabId || !BackgroundProxy.Recorder.captureNetwork)
            return;
        if (params.request && params.request.url && params.request.url.startsWith("chrome-extension://"))
            return;
        if (params.response && params.response.url && params.response.url.startsWith("chrome-extension://"))
            return;

        var item = {
            requestId: params.requestId,
            parentId: params.loaderId,
            wallTime: params.wallTime,
            type: params.type,
            request: [],
            response: [],
            responseBody: { body: "", base64Encoded: false }
        };
        var index = BackgroundProxy.Recorder.requests.findIndex(i => i.requestId === item.requestId);
        var parentIndex = BackgroundProxy.Recorder.requests.findIndex(i => i.requestId === item.parentId);

        var reverseIndex = BackgroundProxy.Recorder.requests.slice().reverse().findIndex(i => i.requestId === item.requestId);
        var count = BackgroundProxy.Recorder.requests.length - 1;
        reverseIndex = reverseIndex >= 0 ? count - reverseIndex : reverseIndex;

        if (message == "Network.requestWillBeSent") {
            if (item.type != "Document" && parentIndex < 0) return;
            item.request = params.request;
            if (params.redirectResponse && index > 0) {
                BackgroundProxy.Recorder.requests[index].response = params.redirectResponse;
            }
            BackgroundProxy.Recorder.requests.push(item);

        } else if (message == "Network.responseReceived" && reverseIndex >= 0) {
            BackgroundProxy.Recorder.requests[reverseIndex].response = params.response;
        } else if (message == "Network.loadingFinished" && reverseIndex >= 0) {
            try {
                chrome.debugger.sendCommand({
                    tabId: BackgroundProxy.Recorder.tabId
                }, "Network.getResponseBody", {
                        "requestId": params.requestId
                    }, function (response) {
                        BackgroundProxy.Recorder.requests[reverseIndex].responseBody = response;
                    });
            } catch (e) { }
        }
    };

    ///////// Analyze recorded traffic //////////////
    this.analyze = function () {

        this.requests = this.requests.filter(x => x.request.url.startsWith('http'));
        if (this.requests.length < 1) return {};

        var result = [];
        try {
            var bgRequestsArr = this.bgRequests.filter(x => x);
            var previousValue = [];
            for (var i = 0; i < this.requests.length; i++) {

                var requestHeaders = [], responseHeaders = [];

                var obj = this.requests[i],
                    type = obj.type == 'Document' ? 'main_frame' : obj.type.toLowerCase(),
                    url = obj.request.urlFragment ? obj.request.url + obj.request.urlFragment : obj.request.url;

                var a = document.createElement('a');
                a.href = url;
                var hostname = a.hostname;
                if (!previousValue[hostname]) previousValue[hostname] = {};

                for (var n = 0; n < bgRequestsArr.length; n++) {
                    if (bgRequestsArr[n].url == url && bgRequestsArr[n].type == type) {
                        bgRequestsArr[n].requestHeaders.forEach(function (item) {
                            if (!BackgroundProxy.Recorder.requests[i].request.headers[item.name])
                                BackgroundProxy.Recorder.requests[i].request.headers[item.name] = item.value;
                        });

                        bgRequestsArr.splice(n, 1);
                        break;
                    }
                }
                if (!BackgroundProxy.Recorder.requests[i].request.headers['Host'])
                    BackgroundProxy.Recorder.requests[i].request.headers['Host'] = hostname;

                var resultObj = { hostname: hostname };
                requestHeaders = Object.keys(obj.request.headers).map(name => ({ name, value: obj.request.headers[name] }));
                requestHeaders.find(function (item) {
                    if (item.name.toLowerCase() == 'cookie' && previousValue[hostname].cookie != item.value) {
                        resultObj.browser = { cookie: { item: {} } };
                        resultObj.browser.cookie = { item: item, request: obj };
                        previousValue[hostname].cookie = item.value;
                    }
                    if (item.name.toLowerCase() == 'authorization' && previousValue[hostname].authorization != item.value) {
                        resultObj.browser = { authorization: { item: {} } };
                        resultObj.browser.authorization = { item: item, request: obj };
                        previousValue[hostname].authorization = item.value;
                    }
                });

                responseHeaders = obj.response.headers ? 
                                    Object.keys(obj.response.headers).map(name => ({ name, value: obj.response.headers[name] })) : [];
                responseHeaders.find(function (item) {
                    if (item.name.toLowerCase() == 'set-cookie') {
                        resultObj.server = { cookie: { item: {} } };
                        resultObj.server.cookie = { item: item, request: obj };
                    }
                });

                if (obj.responseBody && obj.responseBody.body) {
                    var body = obj.responseBody.base64Encoded ? atob(obj.responseBody.body) : obj.responseBody.body,
                        token = body.match(new RegExp('(?:"[^"]*token"\s?:\s?){1}"([A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*)"{1}'));
                    if (token) {
                        resultObj.server = { token: { item: {} } };
                        resultObj.server.token = { item: token[token.length - 1], request: obj };
                    }
                }
                if (resultObj.browser || resultObj.server) {
                    result[i] = resultObj;
                }
            }
        } catch (e) {
            BackgroundProxy.Logger.log("Traffic analysis", e);
        }
        return result;
    };
};//end Recorder


// ---------------------------------------------------------------------------
// Exporter -- a class to render recorded tests
// ---------------------------------------------------------------------------
function Exporter() {
    this.title = "PenTestKit exporter";
    this.items = null;
    this.history = new Array();
    this.last_events = new Array();
    this.screen_id = 1;
    this.unamed_element_id = 1;
    this.output = '';
    this.useEncryption = true;
    this.useDriverEvents = true;
    this.minDuration = 0;
    this.elementPath = "";
    this.debug = false;

    var EventTypes = { OpenUrl: 0, Click: 1, Keypress: 2, Paste: 12, Change: 4 };

    this.stmt = function (text, indent) {
        if (indent == undefined) indent = 1;
        var output = (new Array(4 * indent)).join(" ") + text;
        this.output += text;
    };

    this.pyrepr = function (text, escape) {
        // todo: handle non--strings & quoting
        // There should a more eloquent way of doing this but by  doing the escaping before adding the string quotes prevents the string quotes from accidentally getting escaped creating a syntax error in the output code.
        var s = text;
        if (escape) s = s.replace(/(['"])/g, "\\$1");
        var s = "'" + s + "'";
        return s;
    };

    var d = {};
    d[EventTypes.OpenUrl] = "openUrl";
    d[EventTypes.Click] = "click";
    d[EventTypes.Keypress] = "keypress";
    d[EventTypes.Paste] = "paste";
    d[EventTypes.Change] = "change";

    this.dispatch = d;

    var cc = EventTypes;

    this.renderXml = function (items, options) {
        this.output = '';
        this.items = items;
        var etypes = EventTypes;
        this.useEncryption = options['useEncryption'];
        this.minDuration = options['min_duration'];
        this.elementPath = options['element_path'];
        //this.useDriverEvents = options['use_driver'];
        this.writeHeader();
        var last_down = null;
        var forget_click = false;
        for (var i = 0; i < this.items.length; i++) {
            var item = this.items[i];
            if (i == 0) {
                if (item.type != etypes.OpenUrl) {
                    //this.stmt("ERROR: the recorded sequence does not start with a url openning.");
                    this.output = 'error';
                    return;
                } else {
                    this.startUrl(item);
                    this.delay(item);
                    continue;
                }
            }

            if (this.debug) console.log(item.type);
            if (this.dispatch[item.type]) {
                this[this.dispatch[item.type]](item);
            }
            this.delay(item);
        }
        this.writeFooter();
        return this.output;
    };

    this.formatXml = function (xml) {
        var formatted = '';
        var reg = /(>)(<)(\/*)/g;
        xml = xml.replace(reg, '$1\r\n$2$3');
        var pad = 0;
        jQuery.each(xml.split('\r\n'), function (index, node) {
            var indent = 0;
            if (node.match(/.+<\/\w[^>]*>$/)) {
                indent = 0;
            } else if (node.match(/^<\/\w/)) {
                if (pad != 0) {
                    pad -= 1;
                }
            } else if (node.match(/^<\w([^>]*[^\/])?>.*$/)) {
                indent = 1;
            } else {
                indent = 0;
            }

            var padding = '';
            for (var i = 0; i < pad; i++) {
                padding += '  ';
            }

            formatted += padding + node + '\r\n';
            pad += indent;
        });

        return formatted;
    };

    this.normalizeWhitespace = function (s) {
        return s.replace(/^\s*/, '').replace(/\s*$/, '').replace(/\s+/g, ' ');
    };

    this.shortUrl = function (url) {
        return url.substr(url.indexOf('/', 10), 999999999);
    };

    this.getControl = function (item) {
        var type = item.info.type;
        var tag = item.info.tagName.toLowerCase();
        var selector;
        if ((type == "submit" || type == "button") && item.info.value)
            selector = tag + '[type=' + type + '][value=' + this.pyrepr(this.normalizeWhitespace(item.info.value)) + ']';
        else if (item.info.name || item.info.id)
            selector = tag + '[@name="' + this.pyrepr(item.info.name) + '"]';
        else
            selector = item.info.selector;

        return selector;
    };

    this.getLinkXPath = function (item) {
        var way;
        if (item.text)
            way = 'normalize-space(text())=' + this.cleanStringForXpath(this.normalizeWhitespace(item.text), true);
        else if (item.info.id)
            way = '@id=' + this.pyrepr(item.info.id);
        else if (item.info.href)
            way = '@href=' + this.pyrepr(this.shortUrl(item.info.href));
        else if (item.info.title)
            way = 'title=' + this.pyrepr(this.normalizeWhitespace(item.info.title));

        return way;
    };

    this.GUID = function () {
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0,
                v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16).toUpperCase();
        });
    };

    this.writeHeader = function () {
        this.stmt('<?xml version="1.0"?>\r\n', 0);
        this.stmt("<MacroEventList>\r\n", 0);
    };

    this.writeFooter = function () {
        this.stmt("</MacroEventList>", 0);
    };

    this.eventDuration = function (duration) {
        this.minDuration = parseInt(this.minDuration);
        duration = parseInt(duration);
        if (duration < this.minDuration) duration = this.minDuration + duration + (Math.floor(Math.random() * 111) + 1);
        return duration;
    };

    this.elementPathByType = function (info) {
        if (this.elementPath == "fullpath") return info.fullxpath;
        if (this.elementPath == "javascript") return info.javascript;
        return info.xpath;
    };

    this.commandType = function (info) {
        var retVal = info;
        if (!this.useDriverEvents) return retVal;

        if (info == 'OnClick') retVal = 'DriverClick';
        if (info == 'SetControlData') retVal = 'DriverSetControlValue';

        return retVal;
    };

    this.startUrl = function (item) {
        this.template(item, 'Navigate', item.url, '');
    };

    this.keypress = function (item) {
        this.template(item, this.commandType('SetControlData'), item.text, this.elementPathByType(item.info));
    };

    this.paste = function (item) {
        this.template(item, this.commandType('SetControlData'), item.text, this.elementPathByType(item.info));
    };

    this.click = function (item) {
        this.template(item, this.commandType('OnClick'), (item.info.value != undefined ? item.info.value : ""), this.elementPathByType(item.info));
    };

    this.change = function (item) {
        this.template(item, 'OnChange', (item.info.value != undefined ? item.info.value : ""), this.elementPathByType(item.info));
        this.template(item, this.commandType('SetControlData'), item.text, this.elementPathByType(item.info));
    };

    this.select = function (item) {
        this.template(item, 'OnSelect', (item.info.value != undefined ? item.info.value : ""), this.elementPathByType(item.info));
    };

    this.delay = function (item) {
        this.template(item, 'Delay', '', '');
    };

    this.template = function (item, event, data, path) {
        this.stmt("<MacroEvent>\r\n");
        this.stmt("   <DbId>" + this.GUID() + "</DbId>\r\n");
        this.stmt("   <ParentDbId>00000000000000000000000000000000</ParentDbId>\r\n");
        this.stmt("   <WindowIndex>0</WindowIndex>\r\n");
        this.stmt("   <EventType>" + event + "</EventType>\r\n");
        this.stmt("   <UseEncryptedData>" + ((item.info && item.info.type == "password" && this.useEncryption) ? 1 : 0) + "</UseEncryptedData>\r\n");
        this.stmt("   <Data><![CDATA[" + data + "]]></Data>\r\n");
        this.stmt("   <EncryptedData></EncryptedData>\r\n");
        this.stmt("   <ElementPath><![CDATA[" + path + "]]></ElementPath>\r\n");
        this.stmt("   <Duration>" + this.eventDuration(item.eventDuration) + "</Duration>\r\n");
        this.stmt("   <Enable>1</Enable>\r\n");
        this.stmt("   <Optional>0</Optional>\r\n");
        this.stmt("</MacroEvent>\r\n");
    };

    ///////// HAR file export //////////////
    this.renderHar = function (requests) {

        if (requests.length < 1) return;

        var pages = [];
        var entries = [];
        var requestId = 0;
        for (var i = 0; i < requests.length; i++) {
            var obj = requests[i];
            var postData = null;
            var requestHeaders = [];
            var responseHeaders = [];
            var requestHeaderSize = 0;
            var responseHeaderSize = 0;
            if (obj.response && obj.response.requestHeaders) {
                requestHeaders = Object.keys(obj.response.requestHeaders).map(name => ({ name, value: obj.response.requestHeaders[name] })).filter(item => !item.name.startsWith(":"));
                requestHeaderSize = (JSON.stringify(obj.response.requestHeaders)).length; //obj.response.requestHeadersText.length;
            } else if (obj.request && obj.request.headers) {
                requestHeaders = Object.keys(obj.request.headers).map(name => ({ name, value: obj.request.headers[name] }));
                Object.keys(obj.request.headers).map(name => (requestHeaderSize += name.length + obj.request.headers[name].length));
            }
            if (obj.response && obj.response.headers) {
                responseHeaders = Object.keys(obj.response.headers).map(name => ({ name, value: obj.response.headers[name] }));
            }

            if (obj.type == "Document" && requestId != obj.requestId) {
                var page = {
                    "startedDateTime": (new Date(obj.wallTime).toISOString()),
                    "id": obj.requestId,
                    "title": obj.request.url,
                    "pageTimings": {
                        "onContentLoad": -1,
                        "onLoad": -1
                    }
                };
                pages.push(page);
                requestId = obj.requestId;
            }

            var cookies = [];
            if (obj.response.requestHeaders && obj.response.requestHeaders['Cookie']) {
                var cookieObject = {};
                obj.response.requestHeaders['Cookie'].split('; ').reduce(function (result, v, i, a) {
                    var k = v.split('=');
                    cookies.push({ "name": k[0], "value": k[1], "expires": null, "httpOnly": false, "secure": false });
                }, {});
            }

            if (obj.request.postData) {
                postData = {};
                postData.mimeType = obj.request.headers['Content-Type'];
                postData.text = obj.request.postData;
                var postArray = [];
                try {
                    try {
                        postArray = JSON.parse(obj.request.postData);
                    } catch (e) {
                        postArray = JSON.parse('{"' + decodeURI(obj.request.postData).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
                    }
                    postData.params = Object.keys(postArray).map(name => ({ name, value: postArray[name] }));
                } catch (e) { }
            }

            var entry = {
                "startedDateTime": (new Date(obj.wallTime).toISOString()),
                "time": 204.2114249991181,
                "request": {
                    "method": obj.request.method,
                    "url": obj.request.url,
                    "httpVersion": (obj.response && obj.response.protocol) ? obj.response.protocol.toUpperCase() : "HTTP/1.1",
                    "headers": requestHeaders,
                    "queryString": [],
                    "cookies": cookies,
                    "headersSize": requestHeaderSize,
                    "bodySize": 0
                },
                "response": {
                    "status": obj.response.status,
                    "statusText": obj.response.statusText,
                    "httpVersion": obj.response.protocol ? obj.response.protocol.toUpperCase() : "HTTP/1.1",
                    "headers": responseHeaders,
                    "cookies": [],
                    "content": {
                        "size": (obj.responseBody && obj.responseBody.body) ? obj.responseBody.body.length : 0,
                        "mimeType": obj.response.mimeType,
                        "compression": 0,
                        "text": (obj.responseBody && obj.responseBody.body) ? obj.responseBody.body : "",
                        "encoding": (obj.responseBody && obj.responseBody.base64Encoded) ? "base64" : ""
                    },
                    "redirectURL": "",
                    "headersSize": (obj.response.headersText ? obj.response.headersText.length : 0),
                    "bodySize": (obj.responseBody && obj.responseBody.body) ? obj.responseBody.body.length : 0
                },
                "cache": {},
                "timings": {
                    "send": -1,
                    "receive": -1,
                    "wait": -1
                },
                "serverIPAddress": obj.response.remoteIPAddress,
                "pageref": obj.parentId
            };

            if (postData != null) {
                entry.request.postData = postData;
            }
            entries.push(entry);
        }

        return {
            "log": {
                "version": "1.0",
                "creator": {
                    "name": "PenTestKit",
                    "version": "1.0"
                },
                pages: pages.reverse(),
                entries: entries
            }
        };
    };

    ///////// AppSpider file export //////////////
    this.renderAppSpiderFormat = function (requests) {

        if (requests.length < 1) return [];

        var pages = [];
        var entries = [];
        var requestId = 0;
        for (var i = 0; i < requests.length; i++) {
            var obj = requests[i];
            if (obj.type != 'Document') continue;
            var request = "";
            var response = "";
            if (obj.response && obj.response.requestHeadersText) {
                request = obj.request.method + " " + obj.request.url + " " + obj.response.protocol.toUpperCase() + "\r\n";
                request += Object.keys(obj.response.requestHeaders).map(name =>
                    (name + ": " + obj.response.requestHeaders[name]
                    )).join("\r\n");
            }
            if (obj.response && obj.response.headersText) {
                response = obj.response.headersText.trim();
            }

            if (obj.request.postData) {
                request += "\r\n\r\n" + obj.request.postData;
            }

            if (obj.responseBody && obj.responseBody.body.trim() != "") {
                response += "\r\n\r\n" + (obj.responseBody.base64Encoded ? window.atob(obj.responseBody.body).trim().replace(/(\r\n|\n|\r)/gm, " ") :
                    obj.responseBody.body.trim().replace(/(\r\n|\n|\r)/gm, " "));
            }

            var entry = {
                "request": window.btoa(encodeURIComponent(request)),
                "response": window.btoa(encodeURIComponent(response))
            };

            entries.push(entry);
        }
        return entries;
    };
};//End Exporter


// ---------------------------------------------------------------------------
// Notifications -- manage browser notifications
// ---------------------------------------------------------------------------
function Notifications() {
    this.clearAll = function () {
        chrome.notifications.getAll(function (notifications) {
            if (notifications) {
                for (let key in notifications) {
                    chrome.notifications.clear(key);
                }
            }
        })
    };

    this.notify = function (title, message, clearAll = true) {
        if (clearAll) this.clearAll();
        chrome.notifications.create(
            'PTK_notification', {
                type: 'basic',
                iconUrl: chrome.extension.getURL('browser/assets/images/icon.png'),
                title: title,
                message: message
            },
            function () {
                //setTimeout(function () { chrome.notifications.clear("PTK_notification", function () { }); }, 5000);
            }
        );
    };
}; //end Notifications