'use strict';
(function () {
    var debug = false;
    if (window.PTK_recorder) return;
    //---------------------------------------------------------------------------
    var TestRecorder = {};
    // if (typeof(TestRecorder) == "undefined") {
    //     TestRecorder = {};
    // }

    //---------------------------------------------------------------------------
    //Browser -- a singleton that provides a cross-browser API for managing event 
    //handlers and miscellaneous browser functions.

    //Methods:

    //captureEvent(window, name, handler) -- capture the named event occurring
    //in the given window, setting the function handler as the event handler.
    //The event name should be of the form "click", "blur", "change", etc. 

    //releaseEvent(window, name, handler) -- release the named event occurring
    //in the given window. The event name should be of the form "click", "blur",
    //"change", etc. 

    //getSelection(window) -- return the text currently selected, or the empty
    //string if no text is currently selected in the browser.

    //---------------------------------------------------------------------------

    if (typeof (TestRecorder.Browser) == "undefined") {
        TestRecorder.Browser = {};
    }

    TestRecorder.Browser.captureEvent = function (wnd, name, func) {
        var lname = name.toLowerCase();
        var doc = wnd.document;
        wnd.captureEvents(Event[name.toUpperCase()]);
        wnd["on" + lname] = func;
    }

    TestRecorder.Browser.releaseEvent = function (wnd, name, func) {
        var lname = name.toLowerCase();
        var doc = wnd.document;
        wnd.releaseEvents(Event[name.toUpperCase()]);
        wnd["on" + lname] = null;
    }

    TestRecorder.Browser.getSelection = function (wnd) {
        var doc = wnd.document;
        if (wnd.getSelection) {
            return wnd.getSelection() + "";
        } else if (doc.getSelection) {
            return doc.getSelection() + "";
        } else if (doc.selection && doc.selection.createRange) {
            return doc.selection.createRange().text + "";
        }
        return "";
    }

    TestRecorder.Browser.windowHeight = function (wnd) {
        var doc = wnd.document;
        if (wnd.innerHeight) {
            return wnd.innerHeight;
        } else if (doc.documentElement && doc.documentElement.clientHeight) {
            return doc.documentElement.clientHeight;
        } else if (document.body) {
            return document.body.clientHeight;
        }
        return -1;
    }

    TestRecorder.Browser.windowWidth = function (wnd) {
        var doc = wnd.document;
        if (wnd.innerWidth) {
            return wnd.innerWidth;
        } else if (doc.documentElement && doc.documentElement.clientWidth) {
            return doc.documentElement.clientWidth;
        } else if (document.body) {
            return document.body.clientWidth;
        }
        return -1;
    }


    //---------------------------------------------------------------------------
    //Event -- a class that provides a cross-browser API dealing with most of the
    //interesting information about events.

    //Methods:

    //type() -- returns the string type of the event (e.g. "click")

    //target() -- returns the target of the event

    //button() -- returns the mouse button pressed during the event. Because
    //it is not possible to reliably detect a middle button press, this method 
    //only recognized the left and right mouse buttons. Returns one of the  
    //constants Event.LeftButton, Event.RightButton or Event.UnknownButton for 
    //a left click, right click, or indeterminate (or no mouse click).

    //keycode() -- returns the index code of the key pressed. Note that this 
    //value may differ across browsers because of character set differences. 
    //Whenever possible, it is suggested to use keychar() instead.

    //keychar() -- returns the char version of the key pressed rather than a 
    //raw numeric code. The resulting value is subject to all of the vagaries 
    //of browsers, character encodings in use, etc.

    //shiftkey() -- returns true if the shift key was pressed.

    //posX() -- return the X coordinate of the mouse relative to the document.

    //posY() -- return the y coordinate of the mouse relative to the document.

    //stopPropagation() -- stop event propagation (if supported)

    //preventDefault() -- prevent the default action (if supported)

    //---------------------------------------------------------------------------

    TestRecorder.Event = function (e) {
        this.event = (e) ? e : window.event;
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.Event.LeftButton = 0;
    TestRecorder.Event.MiddleButton = 1;
    TestRecorder.Event.RightButton = 2;
    TestRecorder.Event.UnknownButton = 3;

    TestRecorder.Event.prototype.stopPropagation = function () {
        if (this.event.stopPropagation)
            this.event.stopPropagation();
    }

    TestRecorder.Event.prototype.preventDefault = function () {
        if (this.event.preventDefault)
            this.event.preventDefault();
    }

    TestRecorder.Event.prototype.type = function () {
        return this.event.type;
    }

    TestRecorder.Event.prototype.button = function () {
        if (this.event.button) {
            if (this.event.button == 2) {
                return TestRecorder.Event.RightButton;
            }
            return TestRecorder.Event.LeftButton;
        } else if (this.event.which) {
            if (this.event.which > 1) {
                return TestRecorder.Event.RightButton;
            }
            return TestRecorder.Event.LeftButton;
        }
        return TestRecorder.Event.UnknownButton;
    }

    TestRecorder.Event.prototype.target = function () {
        var t = (this.event.target) ? this.event.target : this.event.srcElement;
        if (t && t.nodeType == 3) // safari bug
            return t.parentNode;
        return t;
    }

    TestRecorder.Event.prototype.keycode = function () {
        return (this.event.keyCode) ? this.event.keyCode : this.event.which;
    }

    TestRecorder.Event.prototype.keychar = function () {
        return String.fromCharCode(this.keycode());
    }

    TestRecorder.Event.prototype.shiftkey = function () {
        if (this.event.shiftKey)
            return true;
        return false;
    }

    TestRecorder.Event.prototype.posX = function () {
        if (this.event.pageX)
            return this.event.pageX;
        else if (this.event.clientX) {
            return this.event.clientX + document.body.scrollLeft;
        }
        return 0;
    }

    TestRecorder.Event.prototype.posY = function () {
        if (this.event.pageY)
            return this.event.pageY;
        else if (this.event.clientY) {
            return this.event.clientY + document.body.scrollTop;
        }
        return 0;
    }



    //---------------------------------------------------------------------------
    //TestCase -- this class contains the interesting events that happen in 
    //the course of a test recording and provides some testcase metadata.

    //Attributes:

    //items -- an array of objects representing test actions and checks


    //---------------------------------------------------------------------------

    TestRecorder.TestCase = function () {
        this.items = new Array();
        this.recorderTimer = (new Date()).getTime();
    }

    TestRecorder.TestCase.prototype.append = function (item) {
        item.eventDuration = item.eventStart - this.recorderTimer;
        if (this.items.length == 1) { //change open url duration
            var duration = item.eventStart - this.items[0].eventStart;
            //if (duration < PTK_recorder.minDuration) duration = PTK_recorder.minDuration + duration;
            this.items[0].eventDuration = duration;
        } else {
            this.recorderTimer = (new Date()).getTime();
        }

        switch (item.type) {
            case TestRecorder.EventTypes.OpenUrl:
                item.eventTypeName = "Navigate";
                break;
            case TestRecorder.EventTypes.Delay:
                item.eventTypeName = "Delay";
                break;
            case TestRecorder.EventTypes.KeyPress:
            case TestRecorder.EventTypes.Paste:
            case TestRecorder.EventTypes.Change:
                item.eventTypeName = "SetValue";
                break;
            case TestRecorder.EventTypes.Click:
                item.eventTypeName = "Click";
                break;
        }
        this.items[this.items.length] = item;

        chrome.storage.local.set({ "pentestkit_recording": { mode: window.PTK_recorder.mode, items: this.items } });
    }

    TestRecorder.TestCase.prototype.peek = function () {
        return this.items[this.items.length - 1];
    }

    TestRecorder.TestCase.prototype.poke = function (o) {
        this.items[this.items.length - 1] = o;
    }

    TestRecorder.TestCase.prototype.pop = function (o) {
        this.items.pop();
    }


    //---------------------------------------------------------------------------
    //Event types -- whenever an interesting event happens (an action or a check)
    //it is recorded as one of the object types defined below. All events have a
    //'type' attribute that marks the type of the event (one of the values in the
    //EventTypes enumeration) and different attributes to capture the pertinent 
    //information at the time of the event.
    //---------------------------------------------------------------------------

    if (typeof (TestRecorder.EventTypes) == "undefined") {
        TestRecorder.EventTypes = {};
    }

    TestRecorder.EventTypes.OpenUrl = 0;
    TestRecorder.EventTypes.Click = 1;
    TestRecorder.EventTypes.KeyPress = 2;
    TestRecorder.EventTypes.Tab = 3;
    TestRecorder.EventTypes.Change = 4;

    TestRecorder.EventTypes.MouseDown = 10;
    TestRecorder.EventTypes.MouseUp = 11;
    TestRecorder.EventTypes.Paste = 12;
    TestRecorder.EventTypes.Delay = 25;

    //TestRecorder.EventTypes.Change = 2;
    //TestRecorder.EventTypes.Submit = 4;


    /*
    TestRecorder.EventTypes.Comment = 3;
    TestRecorder.EventTypes.CheckPageTitle = 5;
    TestRecorder.EventTypes.CheckPageLocation = 6;
    TestRecorder.EventTypes.CheckTextPresent = 7;
    TestRecorder.EventTypes.CheckValue = 8;
    TestRecorder.EventTypes.CheckValueContains = 9;
    TestRecorder.EventTypes.CheckText = 10;
    TestRecorder.EventTypes.CheckHref = 11;
    TestRecorder.EventTypes.CheckEnabled = 12;
    TestRecorder.EventTypes.CheckDisabled = 13;
    TestRecorder.EventTypes.CheckSelectValue = 14;
    TestRecorder.EventTypes.CheckSelectOptions = 15;
    TestRecorder.EventTypes.CheckImageSrc = 16;
    TestRecorder.EventTypes.PageLoad = 17;
    TestRecorder.EventTypes.ScreenShot = 18;
    TestRecorder.EventTypes.MouseDown = 19;
    TestRecorder.EventTypes.MouseUp = 20;
    TestRecorder.EventTypes.MouseDrag = 21;
    TestRecorder.EventTypes.MouseDrop = 22;
    TestRecorder.EventTypes.KeyPress = 23;
    */

    TestRecorder.ElementInfo = function (element, path) {
        this.action = element.action;
        this.method = element.method;
        this.href = element.href;
        this.tagName = element.tagName;
        this.value = element.value != undefined ? element.value : element.innerText;
        this.checked = element.checked;
        this.name = element.name;
        this.type = element.type;
        if (this.type)
            this.type = this.type.toLowerCase();
        if (element.form)
            this.form = { id: element.form.id, name: element.form.name };
        this.src = element.src;
        this.id = element.id;
        this.title = element.title;
        this.options = [];
        if (element.selectedIndex) {
            for (var i = 0; i < element.options.length; i++) {
                var o = element.options[i];
                this.options[i] = { text: o.text, value: o.value };
            }
        }
        this.path = path;
        this.label = this.findLabelText(element);
        this.xpath = this.getElementXPath(element);
        this.fullxpath = this.getElementFullXPath(element);
        this.cssselector = this.getElementCssPath(element);
    }

    TestRecorder.ElementInfo.prototype.findLabelText = function (element) {
        var label = this.findContainingLabel(element)
        var text;
        if (!label) {
            label = this.findReferencingLabel(element);
        }
        if (label) {
            text = label.innerHTML;
            // remove newlines
            text = text.replace('\n', ' ');
            // remove tags
            text = text.replace(/<[^>]*>/g, ' ');
            // remove non-alphanumeric prefixes or suffixes
            text = text.replace(/^\W*/mg, '')
            text = text.replace(/\W*$/mg, '')
            // remove extra whitespace
            text = text.replace(/^\s*/, '').replace(/\s*$/, '').replace(/\s+/g, ' ');
        }

        return text;
    }

    TestRecorder.ElementInfo.prototype.findReferencingLabel = function (element) {
        var labels = window.document.getElementsByTagName('label')
        for (var i = 0; i < labels.length; i++) {
            if (labels[i].attributes['for'] &&
                labels[i].attributes['for'].value == element.id)
                return labels[i]
        }
    }

    TestRecorder.ElementInfo.prototype.findContainingLabel = function (element) {
        var parent = element.parentNode;
        if (!parent)
            return undefined;
        if (parent.tagName && parent.tagName.toLowerCase() == 'label')
            return parent;
        else
            return this.findContainingLabel(parent);
    }

    TestRecorder.ElementInfo.prototype.getIframePath = function (element) {
        var iframeXpath = '';
        if (isIframe && iframeName && iframeName != null) {
            iframeXpath = 'xpath=//IFRAME' + iframeName + '|||>';
        }
        return iframeXpath;
    }

    TestRecorder.ElementInfo.prototype.getElementXPath = function (element) {
        var paths = [];
        // Use nodeName (instead of localName) so namespace prefix is included (if any).
        for (; element && element.nodeType == 1; element = element.parentNode) {
            if (element.nodeName == 'HTML' || (element.previousSibling != null && element.previousSibling.nodeType == Node.DOCUMENT_TYPE_NODE)) {
                break;
            }

            var xPath = element.nodeName.toUpperCase();
            if (element.id) {
                paths.splice(0, 0, xPath + '[@id="' + element.id + '"]');
                break;
            }

            if (element.name) {
                xPath = xPath + '[@name="' + element.name + '"]';
            }

            var index = 0;
            if (element.parentElement && element.parentElement.querySelectorAll(':scope > ' + element.nodeName.toUpperCase()).length > 1) {
                if (element.getAttribute('PTK_originalIndex')) {
                    index = parseInt(element.getAttribute('PTK_originalIndex'));
                } else {
                    var list = element.parentElement.querySelectorAll(':scope > ' + element.nodeName.toUpperCase());
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].isSameNode(element)) index = i;
                    }
                }
            }
            var pathIndex = (index ? "[" + (index) + "]" : "");
            paths.splice(0, 0, xPath + pathIndex);


            let uniquePath = paths.join("/").replace(/\[(\d+)\]/g, function (fullMatch, n) { return "[" + (Number(n) + 1) + "]"; });
            var elementFound = document.evaluate(uniquePath,
                document,
                null,
                XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            if (elementFound.snapshotLength == 1) {
                //paths.splice(0, 0, xPath + '[@name="' + element.name + '"]');
                break;
            }

        }
        return this.getIframePath() + 'xpath=//' + paths.join("/");
    }

    TestRecorder.ElementInfo.prototype.getElementFullXPath = function (element) {
        var originalElement = element;
        var paths = [];
        // Use nodeName (instead of localName) so namespace prefix is included (if any).
        for (; element && element.nodeType == 1; element = element.parentNode) {
            if (element.nodeName == 'HTML' || (element.previousSibling != null && element.previousSibling.nodeType == Node.DOCUMENT_TYPE_NODE)) {
                break;
            }

            var xPath = element.nodeName.toUpperCase();
            if (element.id) {
                xPath = xPath + '[@id="' + element.id + '"]';
            }
            if (element.name) {
                xPath = xPath + '[@name="' + element.name + '"]';
            }
            var index = 0;
            if (element.parentElement && element.parentElement.querySelectorAll(element.nodeName.toUpperCase()).length > 1) {
                if (element.getAttribute('PTK_originalIndex')) {
                    index = parseInt(element.getAttribute('PTK_originalIndex'));
                } else  {
                    var list = element.parentElement.querySelectorAll(':scope > ' + element.nodeName.toUpperCase());
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].isSameNode(element)) index = i;
                    }
                }
            }
            var pathIndex = (index ? "[" + (index) + "]" : "");
            paths.splice(0, 0, xPath + pathIndex);
        }
        return 'xpath=//' + paths.join("/");
    }


    TestRecorder.ElementInfo.prototype.getElementCssPath = function (element) {
        var cssPath = "";
        cssPath = this.getElementCssByPath(element);
        if (document.querySelectorAll(cssPath).length != 1) {
            cssPath = "";
        }
        if (cssPath == "")
            cssPath = this.getElementCss(element);

        return cssPath;
    }

    TestRecorder.ElementInfo.prototype.getElementCss = function (element) {

        var paths = [];
        // Use nodeName (instead of localName) so namespace prefix is included (if any).
        for (; element && element.nodeType == 1; element = element.parentNode) {
            if (element.nodeName == 'HTML' || (element.previousSibling != null && element.previousSibling.nodeType == Node.DOCUMENT_TYPE_NODE)) {
                break;
            }

            var cssPath = element.nodeName.toUpperCase();
            if (element.id) {
                paths.splice(0, 0, cssPath + '[id="' + element.id +'"]');
                break;
            };

            if (element.name) {
                cssPath += '[name="' + (element.name) + '"]';
            };

            // if (element.getAttribute('oldClass') && element.getAttribute('oldClass') == element.className) {
            //     cssPath += "." + element.getAttribute('oldClass').split(' ').filter(function (i) { if (i == 'disabled') return ''; return i; }).join('.');

            // }

            var index = 0;
            let tmpPath = cssPath + (paths.length > 0 ? ">" + paths.join(" > ") : "");
            if (element.parentElement && element.parentElement.querySelectorAll(tmpPath).length > 1) {
                if (element.getAttribute('PTK_originalIndex')) {
                    index = parseInt(element.getAttribute('PTK_originalIndex'));
                } else if (element.parentElement && element.parentElement.children && element.parentElement.children.length > 1) {
                    for (var i = 0; i < element.parentElement.children.length; i++) {
                        if (element.parentElement.children[i].isSameNode(element))
                            index = i;
                    }
                }
            }
            var pathIndex = (index ? ":nth-child(" + (index + 1) + ")" : "");
            paths.splice(0, 0, cssPath + pathIndex);

            if (document.querySelectorAll(paths.join(" > ")).length == 1) {
                break;
            }
        }
        return paths.join(" > ");
    }

    TestRecorder.ElementInfo.prototype.getElementCssByPath = function (element) {
        let originalElement = element;
        var paths = [];
        for (var pathPos = 0; pathPos < this.path.length; pathPos++) {
            element = this.path[pathPos];
            if (element.nodeName == 'HTML') {
                break;
            }

            var cssPath = element.nodeName.toUpperCase();
            if (element.id) {
                paths.splice(0, 0, cssPath + '[id="' + element.id + '"]');
                break;
            };

            if (element.name) {
                cssPath += '[name="' + (element.name) + '"]';
            };

            var index = 0;
            let tmpPath = cssPath + (paths.length > 0 ? ">" + paths.join(" > ") : "");
            if (element.parentElement && element.parentElement.querySelectorAll(tmpPath).length > 1) {
                if (element.getAttribute('PTK_originalIndex')) {
                    index = parseInt(element.getAttribute('PTK_originalIndex'));
                } else if (element.parentElement && element.parentElement.children && element.parentElement.children.length > 1) {
                    for (var i = 0; i < element.parentElement.children.length; i++) {
                        if (element.parentElement.children[i].isSameNode(element))
                            index = i;
                    }
                }
            }

            let pathIndex = (index ? ":nth-child(" + (index + 1) + ")" : "");
            paths.splice(0, 0, cssPath + pathIndex);

            if (document.querySelectorAll(paths.join(" > ")).length == 1) {
                break;
            }
        }
        return paths.join(" > ");
    }

    TestRecorder.DocumentEvent = function (type, target) {
        this.type = type;
        this.url = target.URL;
        this.title = target.title;
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.ElementEvent = function (type, target, text, path) {
        this.type = type;
        this.info = new TestRecorder.ElementInfo(target, path);
        this.text = text; // ? text : PTK_recorder.strip(contextmenu.innertext(target));
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.KeyEvent = function (target, text, path) {
        this.type = TestRecorder.EventTypes.KeyPress;
        this.info = new TestRecorder.ElementInfo(target, path);
        this.text = text;
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.OpenURLEvent = function (url) {
        this.type = TestRecorder.EventTypes.OpenUrl;
        this.url = url;
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.TabEvent = function (type, target) {
        this.type = TestRecorder.EventTypes.Tab;
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.DelayEvent = function () {
        this.type = TestRecorder.EventTypes.Delay;
        this.eventStart = (new Date()).getTime();
    }

    TestRecorder.PageLoadEvent = function (url) {
        this.type = TestRecorder.EventTypes.OpenUrl;
        this.url = url;
        this.viaBack = back
    }

    // TestRecorder.MouseEvent = function (type, target, x, y) {
    //     this.type = type;
    //     this.info = new TestRecorder.ElementInfo(target);
    //     this.x = x;
    //     this.y = y;
    //     this.eventStart = (new Date()).getTime();
    // }


    //---------------------------------------------------------------------------
    //Recorder -- a controller class that manages the recording of web browser
    //activities to produce a test case.

    //Instance Methods:

    //start() -- start recording browser events.

    //stop() -- stop recording browser events.

    //reset() -- reset the PTK_recorder and initialize a new test case.

    //---------------------------------------------------------------------------

    TestRecorder.Recorder = function () {
        this.testcase = new TestRecorder.TestCase();
        this.logfunc = null;
        this.window = null;
        //this.iframeName = iframeName;
        this.iframesCollection = [];
    }

    TestRecorder.Recorder.prototype.start = function () {
        this.window = window;
        this.captureEvents();
        // OVERRIDE stopPropagation

        var actualCode = '(' + function () {
            var overloadStopPropagation = Event.prototype.stopPropagation;
            Event.prototype.stopPropagation = function () {
                overloadStopPropagation.apply(this, arguments);
                this.target.dispatchEvent(new MouseEvent('customRecorderEvent', this));
            };
        } + ')();';
        var script = document.createElement('script');
        script.textContent = actualCode;
        (document.head || document.documentElement).appendChild(script);
        script.parentNode.removeChild(script);
    }

    TestRecorder.Recorder.prototype.stop = function () {
        this.releaseEvents();
        return;
    }

    TestRecorder.Recorder.prototype.open = function (url) {
        chrome.storage.local.set({ "pentestkit_recording": { mode: this.mode, items: new Array() } }, function () {
            var e = new TestRecorder.OpenURLEvent(url);
            window.PTK_recorder.testcase.append(e);
        });
    }

    TestRecorder.Recorder.prototype.init = function (items) {
        if (items.length > 0)
            this.testcase.items = items;
        if (debug) console.log('init');
    }

    TestRecorder.Recorder.prototype.pageLoad = function () {
        var doc = PTK_recorder.window.document;
        var et = TestRecorder.EventTypes;
        var e = new TestRecorder.DocumentEvent(et.PageLoad, doc);
        this.testcase.append(e);
        this.log("page loaded url: " + e.url);
    }

    TestRecorder.Recorder.prototype.captureEvents = function () {
        var wnd = this.window;
        /*
        TestRecorder.Browser.captureEvent(wnd, "drag", this.ondrag);
        TestRecorder.Browser.captureEvent(wnd, "mousedown", this.onmousedown);
        TestRecorder.Browser.captureEvent(wnd, "mouseup", this.onmouseup);
        TestRecorder.Browser.captureEvent(wnd, "keypress", this.onkeypress);
        TestRecorder.Browser.captureEvent(wnd, "keydown", this.onkeydown);
        TestRecorder.Browser.captureEvent(wnd, "select", this.onselect);
        TestRecorder.Browser.captureEvent(wnd, "submit", this.onsubmit);
        TestRecorder.Browser.captureEvent(wnd, "click", this.onclick);
        TestRecorder.Browser.captureEvent(wnd, "change", this.onchange);
        */

        //document.addEventListener("mousedown", this.onmousedown);
        //document.addEventListener("mouseup", this.onmouseup);
        document.addEventListener("click", this.onclick);
        document.addEventListener("keypress", this.onkeypress);
        document.addEventListener("keydown", this.onkeydown);
        document.addEventListener("paste", this.onpaste);
        document.addEventListener("change", this.onchange);
        document.addEventListener("select", this.onselect);
        document.addEventListener("customRecorderEvent", this.oncustomevent);


        this.mutationObserver = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
                if (mutation.type == 'attributes' && mutation.attributeName == 'class' && mutation.oldValue) {
                    if (!mutation.target.getAttribute("PTK_originalClass"))
                        mutation.target.setAttribute("PTK_originalClass", mutation.oldValue);
                }
                if (mutation.type == 'childList' && mutation.addedNodes.length > 0) {
                    let addedNode = mutation.addedNodes[0];
                    var count = 0;
                    for (var i = 0; i < mutation.target.children.length; i++) {
                        if (mutation.target.children[i].tagName == addedNode.tagName) {
                            mutation.target.children[i].setAttribute("PTK_originalIndex", count);
                            count++;
                        }
                    }
                }
                if (mutation.type == 'childList' && mutation.removedNodes.length > 0) {
                    let removedNode = mutation.removedNodes[0];
                    var count = 0;
                    for (var i = 0; i < mutation.target.children.length; i++) {
                        if (mutation.target.children[i].tagName == removedNode.tagName && mutation.target.children[i].getAttribute("PTK_originalIndex")) {
                            count = parseInt(mutation.target.children[i].getAttribute("PTK_originalIndex"));
                            mutation.target.children[i].setAttribute("PTK_originalIndex", (count-1));
                        }
                    }
                }
            });
        });

        this.mutationObserver.observe(document, {
            attributes: true,
            subtree: true,
            attributeOldValue: true,
            attributeFilter: ["class"],
            childList: true
            /*
            characterData: true,
            
            characterDataOldValue: true*/
        });
    }

    TestRecorder.Recorder.prototype.releaseEvents = function () {
        var wnd = this.window;
        /*
        TestRecorder.Browser.releaseEvent(wnd, "drag", this.ondrag);
        TestRecorder.Browser.releaseEvent(wnd, "mousedown", this.onmousedown);
        TestRecorder.Browser.releaseEvent(wnd, "mouseup", this.onmouseup);
        TestRecorder.Browser.releaseEvent(wnd, "keypress", this.onkeypress);
        TestRecorder.Browser.releaseEvent(wnd, "keydown", this.onkeydown);
        TestRecorder.Browser.releaseEvent(wnd, "select", this.onselect);
        TestRecorder.Browser.releaseEvent(wnd, "submit", this.onsubmit);
        TestRecorder.Browser.releaseEvent(wnd, "click", this.onclick);
        TestRecorder.Browser.releaseEvent(wnd, "change", this.onchange);
        */

        //document.removeEventListener("mousedown", this.onmousedown);
        //document.removeEventListener("mouseup", this.onmouseup);
        document.removeEventListener("click", this.onclick);
        document.removeEventListener("keypress", this.onkeypress);
        document.removeEventListener("keydown", this.onkeydown);
        document.removeEventListener("paste", this.onpaste);
        document.removeEventListener("change", this.onchange);
        document.removeEventListener("select", this.onselect);
        document.removeEventListener("customRecorderEvent", this.oncustomevent);
        this.mutationObserver.disconnect();
    }

    TestRecorder.Recorder.prototype.clickaction = function (e) {
        // This method is called by our low-level event handler when the mouse 
        // is clicked in normal mode. Its job is decide whether the click is
        // something we care about. If so, we record the event in the test case.
        //
        var et = TestRecorder.EventTypes;
        var t = e.target();
        var el = new TestRecorder.ElementEvent(et.Click, e.target(), "", e.event.path);
        var elData = null;

        if (el.info && el.info.xpath.includes('PTK_RecordingMessageCenter')) return;

        if (t.type && t.type == "checkbox" || t.type && t.type == "radio") {
            elData = new TestRecorder.KeyEvent(e.target(), t.value, e.event.path);
        }
        var addNewEvent = true;
        var last = PTK_recorder.testcase.peek();
        if (last != undefined && last.type == el.type && (el.eventStart - last.eventStart) < 1000) {
            addNewEvent = false;
        }
        if (addNewEvent) PTK_recorder.testcase.append(el);
        if (elData != null) PTK_recorder.testcase.append(elData);
    }

    TestRecorder.Recorder.prototype.check = function (e) {
        // This method is called by our low-level event handler when the mouse 
        // is clicked in check mode. Its job is decide whether the click is
        // something we care about. If so, we record the check in the test case.
        var target = e.target();
        if (target.type) {
            var type = target.type.toLowerCase();
            if (type == "submit" || type == "button" || type == "image") {
                PTK_recorder.log('check button == "' + target.value + '"');
            }
        } else if (target.href) {
            if (target.innerText) {
                var text = PTK_recorder.strip(target.innerText);
                PTK_recorder.log('check link == "' + target.text + '"');
            }
        }
    }

    TestRecorder.Recorder.prototype.onchange = function (e) {
        if (e.srcElement.type != 'select-one') return;
        var e = new TestRecorder.Event(e);
        var et = TestRecorder.EventTypes;
        var v = new TestRecorder.ElementEvent(et.Change, e.target(), e.target().value, e.event.path);
        PTK_recorder.testcase.append(v);
        PTK_recorder.log("value changed: " + e.target().value);
    }

    TestRecorder.Recorder.prototype.onselect = function (e) {
        var e = new TestRecorder.Event(e);
        PTK_recorder.log("select: " + e.target());
    }

    TestRecorder.Recorder.prototype.onsubmit = function (e) {
        var e = new TestRecorder.Event(e);
        var et = TestRecorder.EventTypes;
        // We want to save the form element as the event target
        var t = e.target();
        while (t.parentNode && t.tagName != "FORM") {
            t = t.parentNode;
        }
        var v = new TestRecorder.ElementEvent(et.Submit, t);
        PTK_recorder.testcase.append(v);
        PTK_recorder.log("submit: " + e.target());
    }

    TestRecorder.Recorder.prototype.onmousedown = function (e) {
        var e = new TestRecorder.Event(e);
        if (e.button() == TestRecorder.Event.LeftButton) {
            var el = new TestRecorder.ElementEvent(TestRecorder.EventTypes.MouseDown, e.target(), "", e.event.path);
            PTK_recorder.testcase.append(el);
        }
    }

    TestRecorder.Recorder.prototype.onmouseup = function (e) {
        var e = new TestRecorder.Event(e);
        if (e.button() == TestRecorder.Event.LeftButton) {
            var last = PTK_recorder.testcase.peek();
            if (last.type == TestRecorder.EventTypes.MouseDown) {

            }
        }
    }

    /*
    //The dance here between onclick and oncontextmenu requires a bit of 
    //explanation. IE and Moz/Firefox have wildly different behaviors when 
    //a right-click occurs. IE6 fires only an oncontextmenu event; Firefox 
    //gets an onclick event first followed by an oncontextment event. So 
    //to do the right thing here, we need to silently consume oncontextmenu
    //on Firefox, and reroute oncontextmenu to look like a click event for 
    //IE. In both cases, we need to prevent the default action for cmenu.
    */

    TestRecorder.Recorder.prototype.onclick = function (e) {
        if (e && e.srcElement && e.srcElement.id.startsWith('PTK_RecordingMessageCenter'))
            return false;
        var e = new TestRecorder.Event(e);
        if (e.button() == TestRecorder.Event.LeftButton) {
            PTK_recorder.clickaction(e);
        }
        return true;
    }


    TestRecorder.Recorder.prototype.oncustomevent = function (e) {
        var evt = new TestRecorder.Event(e);
        if (evt.button() == TestRecorder.Event.LeftButton && (e.x != 0 && e.y != 0)) {
            PTK_recorder.clickaction(evt);
        }
        return true;
    }

    TestRecorder.Recorder.prototype.onkeypress = function (e) {
        e.stopImmediatePropagation();
        var e = new TestRecorder.Event(e);
        var code = e.event.keyCode || e.event.which;
        if (code == 9 || code == 13) return false;
        var last = PTK_recorder.testcase.peek();
        if (last.type == TestRecorder.EventTypes.KeyPress) {
            var lkey = last.text;
            last.text = last.text + e.keychar();
            last.eventStart = (new Date()).getTime();
            PTK_recorder.testcase.poke(last);
        } else {
            PTK_recorder.testcase.append(
                new TestRecorder.KeyEvent(e.target(), e.keychar(), e.event.path)
            );
        }
        PTK_recorder.sync(PTK_recorder.testcase.items);
        return false;
    }

    TestRecorder.Recorder.prototype.onkeydown = function (e) {
        e.stopImmediatePropagation();
        var e = new TestRecorder.Event(e);
        var code = e.event.keyCode || e.event.which;
        if (code == 9 || code == 13) {
            setTimeout(function (e) {
                document.activeElement.click();
            }, 100, e)
            //PTK_recorder.clickaction(e);
        }
        //backspace or delete
        if (code == 8 || code == 46) {
            var selectedTxt = document.getSelection().toString(),
                posStart = e.event.target.selectionStart,
                posEnd = e.event.target.selectionEnd,
                last = PTK_recorder.testcase.peek();
            if (last.type == TestRecorder.EventTypes.Click) {
                PTK_recorder.testcase.pop();
                last = PTK_recorder.testcase.peek();
            }
            if (code == 46) posStart++;

            if (selectedTxt == "") {
                if (last.type == TestRecorder.EventTypes.KeyPress) {
                    var text = last.text;
                    if (last.text.length == 0) {
                        return false;
                    } else if (last.text.length == posStart) { //deleted at the end
                        text = last.text.substring(0, posStart - 1);
                    } else {
                        text = last.text.substring(0, posStart - 1);
                        text += last.text.substring(posStart, last.text.length);
                    }
                    last.text = text;
                    last.eventStart = (new Date()).getTime();
                }
            } else {
                last.text = last.text.replace(selectedTxt, "");
            }
            PTK_recorder.testcase.poke(last);
        }
        PTK_recorder.sync(PTK_recorder.testcase.items);
        return false;
    }

    TestRecorder.Recorder.prototype.onload = function (e) {
        if (window.PTK_recorder.mode == 'recording') {
            chrome.storage.local.get('pentestkit_recording', function (result) {
                let syncItems = result.pentestkit_recording.items;
                let previousEl = syncItems[syncItems.length - 1];
                if (previousEl.eventTypeName != 'Delay') {
                    var el = new TestRecorder.DelayEvent();
                    window.PTK_recorder.testcase.items = result.pentestkit_recording.items;
                    window.PTK_recorder.testcase.append(el);
                    window.PTK_recorder.sync(window.PTK_recorder.testcase.items);
                }
            });
        }
    }

    TestRecorder.Recorder.prototype.onpaste = function (e) {
        var text = e.clipboardData.getData('Text');
        var e = new TestRecorder.Event(e);
        var el = new TestRecorder.ElementEvent(TestRecorder.EventTypes.Paste, e.target(), text, e.event.path);
        PTK_recorder.testcase.append(el);
    }


    TestRecorder.Recorder.prototype.strip = function (s) {
        return s.replace('\n', ' ').replace(/^\s*/, "").replace(/\s*$/, "");
    }

    TestRecorder.Recorder.prototype.log = function (text) {
        if (this.logfunc) {
            this.logfunc(text);
        }
    }

    TestRecorder.Recorder.prototype.sync = function (items) {
        chrome.storage.local.set({ "pentestkit_recording": { mode: window.PTK_recorder.mode, items: items } }, function () {
            window.PTK_recorder.testcase.items = items;
        });
    }

    TestRecorder.Recorder.prototype.replay = async function (replayEvents, replay_step, validateRegex) { // We need to wrap the loop into an async function for this to work

        if (replay_step >= replayEvents.length) {
            PTK_recorder.validateRegex(validateRegex);
            setTimeout(
                window.postMessage({
                    channelName: "PTK_recorder_runtime",
                    message: 'replay completed'
                }), 1000);
            return;
        }

        var iframeEvent = false;
        var eventIframeName = null;
        var event = replayEvents[replay_step];

        var xpath = event.ElementPath;
        if (xpath.includes('//IFRAME')) {
            iframeEvent = true;
            [eventIframeName, xpath] = xpath.split('|||>');
        }

        if (!isIframe && iframeEvent) {
            //console.log('main frame, iframe event - send message')
            var frames = document.getElementsByTagName('iframe');
            if (frames && frames.length) {
                for (var i = 0; i < frames.length; i++) {
                    if (eventIframeName.includes(frames[i].name) || eventIframeName.includes(frames[i].id)) {
                        frames[i].contentWindow.postMessage({
                            channelName: "PTK_recorder_runtime",
                            message: 'replay'
                        }, '*');
                    }
                }
            }

            return;
        } else if (isIframe && !iframeEvent) {
            //do nothing in case of javascript event
            if (event.EventType.toLowerCase() != 'javascript') return;

            //console.log('sub frame, not iframe event - send message')
            window.parent.postMessage({
                channelName: "PTK_recorder_runtime",
                message: 'replay'
            }, '*');
            return;
        } else if (isIframe && iframeEvent && !eventIframeName.includes(iframeName)) {
            //console.log('sub frame, not our - do nothing')
            return;
        }

        xpath = xpath.replace('xpath=', '').replace(/\[(\d+)\]/g, function (fullMatch, n) { return "[" + (Number(n) + 1) + "]"; })
        if (!xpath.startsWith('//')) xpath = '/' + xpath;

        var element = document.evaluate(xpath,
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        chrome.storage.local.set({
            "pentestkit_recording": {
                mode: window.PTK_recorder.mode,
                replayItems: replayEvents,
                replayStep: replay_step + 1,
                validateRegex: validateRegex
            }
        });

        switch (event.EventType.toLowerCase()) {
            case "onclick":
            case "driverclick":
                if (element == null && event.Optional == 0) {
                    alert('Could not execute an event: ' + event.EventType + ' ( Xpath: ' + xpath + ')');
                    return;
                } else if (element)
                    element.click();
                break;
            case "setcontroldata":
            case "driversetcontrolvalue":
            case "driversendkeys":
                if (element == null && event.Optional == 0) {
                    alert('Could not execute an event: ' + event.EventType + ' ( Xpath: ' + xpath + ')');
                    return;
                } else if (element) {
                    element.value = event.Data;
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                }
                break;
            case "javascript":
                try {
                    eval(event.Data);
                } catch (e) {
                    alert('Could not execute an event: ' + e.message + event.Data);
                }
                break;
            case "onchange":
                element.value = event.Data;
                break;
            case "delay":
            case "navigate":
                break;
            default:
                alert('Unknown event: ' + event.EventType + ' ( Xpath: ' + xpath + ')');
                break;
        }
        setTimeout(PTK_recorder.replay, event.Duration, replayEvents, (replay_step + 1), validateRegex);
    }

    TestRecorder.Recorder.prototype.validateRegex = function (validateRegex) {
        if (validateRegex) {
            var regex = new RegExp(validateRegex);
            if (regex.test(document.body.innerHTML)) {
                var str = regex.exec(document.body.innerHTML);
                alert('Successfully match: ' + str[0]);
            } else {
                alert('Match not found');
            }
        }
    }



    //Detect if this iframe or not
    var isIframe = false;
    var iframeName = null;
    try {
        isIframe = window.self !== window.top;
    } catch (e) {
        isIframe = true;
    }
    if (isIframe) {
        iframeName = window.name;
        try {
            if (PTK_framesCollection) {
                for (var i = 0; i < window.parent.frames.length; i++) {
                    if (window.parent.frames[i] == window && PTK_framesCollection[i]) {
                        if (PTK_framesCollection[i].name) {
                            iframeName = '[@name="' + PTK_framesCollection[i].name + '"]';
                            PTK_framesCollection[i].iframeName = iframeName;
                        }
                        if (PTK_framesCollection[i].id) {
                            iframeName = '[@id="' + PTK_framesCollection[i].id + '"]';
                            PTK_framesCollection[i].iframeName = iframeName;
                        }
                    }
                }
            }
        } catch (e) { }
    }


    window.addEventListener("message", (event) => {
        if (event.data.channelName == 'PTK_recorder_runtime' && event.data.message == 'replay') {
            chrome.storage.local.get('pentestkit_recording', function (result) {
                var storage = result.pentestkit_recording;
                PTK_recorder.replay(storage.replayItems, storage.replayStep, storage.validateRegex);
            });
        }
    });

    chrome.storage.local.get('pentestkit_recording', function (result) {

        var storage = result.pentestkit_recording;
        var PTK_recorder = new TestRecorder.Recorder();
        PTK_recorder.logfunc = function (msg) { console.log(msg); };
        window.PTK_recorder = PTK_recorder;
        window.PTK_recorder.mode = storage.mode;

        if (storage.mode == 'recording') {
            PTK_recorder.start();
            if (storage.startUrl) {
                PTK_recorder.open(storage.startUrl);
            } else if (storage.items) {
                PTK_recorder.init(storage.items);
            }
        } else if (storage.mode == 'replay') {
            PTK_recorder.replay(storage.replayItems, storage.replayStep, storage.validateRegex);
        }
        setTimeout(PTK_recorder.onload, 500);
    });

})();