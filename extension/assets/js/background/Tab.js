/* Author: Denis Podgurskii */
'use strict';
////////////////////////////////////
/* Tab */
////////////////////////////////////
/*
{frames: new Map[ frameId: new Map [requestId: [item: {request: object, response: object} ] ] ] }
*/

function Tab(tabId, params, type) {
    this.setParams = function (params, type) {
        if (Number.isInteger(params.frameId)) {
            //Init frame map if doesn't exist
            if (!this.frames.has(params.frameId)) {
                this.frames.set(params.frameId, new Map());
                BackgroundProxy.Logger.log("Init frames", { frameId: params.frameId, requestId: params.requestId });
            }
            //Init request map if doesn't exist
            if (!this.frames.get(params.frameId).has(params.requestId)) {
                this.frames.get(params.frameId).set(params.requestId, new Array());
            }
            var index = this.frames.get(params.frameId).get(params.requestId).length;
            if (type == 'start' || index == 0) {
                this.frames.get(params.frameId).get(params.requestId).push(params);
                BackgroundProxy.Logger.log("Add new item for ", { frameId: params.frameId, requestId: params.requestId });
            } else {
                for (var p in params) {
                    let requestKey = index == 0 ? 0 : index - 1;
                    if (this.frames.get(params.frameId).get(params.requestId)[requestKey][p] != params[p]) {
                        this.frames.get(params.frameId).get(params.requestId)[requestKey][p] = params[p];
                    }
                }
                BackgroundProxy.Logger.log("Updated params ", { params: params, frameId: params.frameId, requestId: params.requestId });
            }
        } else {
            for (var p in params) {
                this[p] = params[p];
                BackgroundProxy.Logger.log("Add or update param ", { p: params[p] });
            }
        }
    };

    this.reduceTabSize = function (maxRequest) {
        this.frames.forEach((frame, fkey) => {
            frame.forEach((request, rkey) => {
                if (frame.size >= maxRequest) {
                    frame.delete(rkey);
                }
            });
        });
    };


    this.tabId = tabId;
    this.frames = new Map();
    this.setParams(params, type);
}; //end Tab