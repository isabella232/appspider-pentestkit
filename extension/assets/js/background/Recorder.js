/* Author: Denis Podgurskii */
'use strict';
////////////////////////////////////
/* Recorder */
////////////////////////////////////

function Recorder() {
    this.replay_step = 0;
    this.replayEvents = [];
    this.mode = null; // recording || replay
    this.validateRegex = null;
    this.recorderJS = "assets/js/content/recorder.js";
    this.recorderMainJS = "assets/js/content/recorderMain.js"; // only for top frame
    this.tabId = null;
    this.openerTabId = null;
    this.items = [];
    this.startUrl = null;
    this.minDuration = 8000;
    this.elementPath = "id"; // fullpath
    this.eventType = "DriverClick"; // OnClick, Javascript
    this.enableRegex = false;
    this.playbackRegex = "";
    this.iFramesDetected = false;
    //traffic recording
    this.requests = [];
    this.captureNetwork = false;
    this.cleanCookie = false;
    this.bgRequests = [];
    //bootstrap
    this.bootstrapJobID = null;
    this.bootstrapEndpoint = null;
    this.bootstrapPutParams = null;
    this.bootstrapUsePut = false;

    this.savedMacro = "";


    this.start = function (data) {
        if (this.mode == null) {

            this.items = [];
            this.requests = [];
            this.bgRequests = [];
            this.startUrl = data.start_url
            this.mode = 'recording';

            var domain = (new URL(this.startUrl)).hostname;
            if (this.cleanCookie) {
                chrome.cookies.getAll({ domain: domain }, function (cookies) {
                    var url = new URL(BackgroundProxy.Recorder.startUrl);
                    for (var i = 0; i < cookies.length; i++) {
                        chrome.cookies.remove({
                            url: url.protocol + "//" + cookies[i].domain + cookies[i].path,
                            name: cookies[i].name
                        });
                    }
                });
            }
            // setTimeout(function () {
            chrome.storage.local.set({ "pentestkit_recording": { mode: "recording", items: new Array(), startUrl: BackgroundProxy.Recorder.startUrl } }, function () {
                chrome.windows.create({ url: 'about:blank', type: "popup", incognito: data.incognito },
                    function (win) {
                        BackgroundProxy.Recorder.tabId = win.tabs[0].id;
                        if (BackgroundProxy.Recorder.captureNetwork) {
                            //Attach debugger
                            var version = "1.3";
                            var debugTarget = { tabId: BackgroundProxy.Recorder.tabId };
                            chrome.debugger.attach(debugTarget, version,
                                BackgroundProxy.Recorder.onAttach(null, BackgroundProxy.Recorder.tabId)
                            );
                            chrome.debugger.sendCommand(debugTarget, "Network.setCacheDisabled", { cacheDisabled: true });
                            chrome.debugger.sendCommand(debugTarget, "Network.enable");
                        }
                        //should be an alert, so a user can confirm start recording
                        alert("You are now recording a macro/traffic sequence");
                        chrome.windows.update(win.id, { "focused": true });
                        chrome.tabs.update(BackgroundProxy.Recorder.tabId, { url: BackgroundProxy.Recorder.startUrl });
                    });
            });
            //}, 100);

        } else {
            BackgroundProxy.Notifications.notify("Recording/playback already started", "Stop recording before start a new one");
        }
    };

    this.startMacro = function (data) {
        this.captureNetwork = true;
        this.start(data);
    };

    this.startTraffic = function (data) {
        this.captureNetwork = true;
        this.start(data);
    };

    this.startBootstrap = function (data) {
        this.cleanCookie = true;
        this.captureNetwork = true;
        this.bootstrapJobID = data.jobID;
        this.bootstrapEndpoint = data.restAPI;
        this.bootstrapPutParams = data.putParams ? data.putParams : null;
        this.bootstrapUsePut = data.usePut ? data.usePut : false;
        this.start(data);
    };

    // this.append = function (data) {
    //     this.items = data.items;
    // };

    this.reset = function () {
        this.stop();
        this.items = [];
        this.requests = [];
        this.bgRequests = [];
        this.replayEvents = [];
        this.validateRegex = null;

        this.cleanCookie = false;
        this.startUrl = null;

        this.replay_step = 0;
        this.mode = null;
        this.captureNetwork = false;
        this.openerTabId = null;

        this.bootstrapJobID = null;
        this.bootstrapEndpoint = null;
        this.bootstrapPutParams = null;
        this.bootstrapUsePut = false;

        this.minDuration = 8000;
        this.elementPath = "id";
        this.eventType = "DriverClick";
        this.enableRegex = false;
        this.playbackRegex = "";
        this.iFramesDetected = false;

        this.savedMacro = "";
    };

    this.stop = function (removeInfo) {

        if (this.cleanCookie && this.startUrl != null) {
            var domain = (new URL(this.startUrl)).hostname;
            chrome.cookies.getAll({ domain: domain }, function (cookies) {
                if (BackgroundProxy.Recorder.startUrl) {
                    var url = new URL(BackgroundProxy.Recorder.startUrl);
                    for (var i = 0; i < cookies.length; i++) {
                        chrome.cookies.remove({
                            url: url.protocol + "//" + cookies[i].domain + cookies[i].path,
                            name: cookies[i].name
                        });
                    }
                }
                BackgroundProxy.Recorder.cleanCookie = false;
                BackgroundProxy.Recorder.startUrl = null;
            });
        }

        try {
            if (removeInfo == null && BackgroundProxy.Recorder.tabId != null) {
                chrome.tabs.get(BackgroundProxy.Recorder.tabId, function (tab) {
                    if (tab && tab.id) chrome.tabs.remove(tab.id);
                });
            }
        } catch (e) {
            console.log(e)
        }

        chrome.storage.local.get('pentestkit_recording', function (result) {
            if (result.pentestkit_recording && result.pentestkit_recording.mode == 'recording') {
                BackgroundProxy.Recorder.items = result.pentestkit_recording.items;
                chrome.runtime.sendMessage({
                    channel: "ptkBackgroundToPopup",
                    type: "recording completed"
                });
            }
            chrome.storage.local.remove('pentestkit_recording');
        });

        this.replayEvents = [];
        this.validateRegex = null;
        this.tabId = null;
        this.replay_step = 0;
        this.mode = null;
        this.captureNetwork = false;
    };

    this.replay = function (data) {
        if (this.mode == null) {
            this.replayEvents = data.events;
            this.mode = 'replay';
            this.replay_step = 1;
            this.validateRegex = data.validateRegex;

            chrome.storage.local.set({
                "pentestkit_recording": {
                    mode: "replay",
                    replayItems: data.events,
                    replayStep: 0,
                    validateRegex: data.validateRegex
                }
            }, function () {
                chrome.windows.create({ url: data.url, type: "popup" },
                    function (win) {
                        BackgroundProxy.Recorder.tabId = win.tabs[0].id;
                        alert("You are now starting a macro playback");
                        chrome.windows.update(win.id, { "focused": true });
                    });
            });
        } else {
            BackgroundProxy.Notifications.notify("Recording/playback already started", "Stop playback/recording before start a new one");
        }
    };

    this.onAttach = function (tabId) {
        if (chrome.runtime.lastError) {
            alert(chrome.runtime.lastError.message);
            return;
        }
        chrome.debugger.onEvent.addListener(BackgroundProxy.Recorder.onEvent);
        chrome.debugger.onDetach.addListener(BackgroundProxy.Recorder.onDetach);
    };

    this.onDetach = function () {
        chrome.debugger.onEvent.removeListener(BackgroundProxy.Recorder.onEvent);
        chrome.debugger.onDetach.removeListener(BackgroundProxy.Recorder.onDetach);
    };

    this.onEvent = function (debuggeeId, message, params) {

        if (BackgroundProxy.Recorder.tabId != debuggeeId.tabId || !BackgroundProxy.Recorder.captureNetwork)
            return;
        if (params.request && params.request.url && params.request.url.startsWith("chrome-extension://"))
            return;
        if (params.response && params.response.url && params.response.url.startsWith("chrome-extension://"))
            return;

        var item = {
            requestId: params.requestId,
            parentId: params.loaderId,
            wallTime: params.wallTime,
            type: params.type,
            request: [],
            response: [],
            responseBody: { body: "", base64Encoded: false }
        };
        var index = BackgroundProxy.Recorder.requests.findIndex(i => i.requestId === item.requestId);
        var parentIndex = BackgroundProxy.Recorder.requests.findIndex(i => i.requestId === item.parentId);

        var reverseIndex = BackgroundProxy.Recorder.requests.slice().reverse().findIndex(i => i.requestId === item.requestId);
        var count = BackgroundProxy.Recorder.requests.length - 1;
        reverseIndex = reverseIndex >= 0 ? count - reverseIndex : reverseIndex;

        if (message == "Network.requestWillBeSent") {
            if (item.type != "Document" && parentIndex < 0) return;
            item.request = params.request;
            if (params.redirectResponse && index > 0) {
                BackgroundProxy.Recorder.requests[index].response = params.redirectResponse;
            }
            BackgroundProxy.Recorder.requests.push(item);

        } else if (message == "Network.responseReceived" && reverseIndex >= 0) {
            BackgroundProxy.Recorder.requests[reverseIndex].response = params.response;
        } else if (message == "Network.loadingFinished" && reverseIndex >= 0) {
            try {
                chrome.debugger.sendCommand({
                    tabId: BackgroundProxy.Recorder.tabId
                }, "Network.getResponseBody", {
                    "requestId": params.requestId
                }, function (response) {
                    BackgroundProxy.Recorder.requests[reverseIndex].responseBody = response;
                });
            } catch (e) {
                console.log(e)
            }
        }
    };

    ///////// Analyze recorded traffic //////////////
    this.analyze = function () {

        this.requests = this.requests.filter(x => x.request.url.startsWith('http'));
        if (this.requests.length < 1) return {};

        var result = [];
        try {
            var bgRequestsArr = this.bgRequests.filter(x => x);
            var previousValue = [];
            for (var i = 0; i < this.requests.length; i++) {

                var requestHeaders = [], responseHeaders = [];

                var obj = this.requests[i],
                    type = obj.type == 'Document' ? 'main_frame' : obj.type.toLowerCase(),
                    url = obj.request.urlFragment ? obj.request.url + obj.request.urlFragment : obj.request.url;

                var a = document.createElement('a');
                a.href = url;
                var hostname = a.hostname;
                if (!previousValue[hostname]) previousValue[hostname] = {};

                for (var n = 0; n < bgRequestsArr.length; n++) {
                    if (bgRequestsArr[n].url == url && bgRequestsArr[n].type == type) {
                        bgRequestsArr[n].requestHeaders.forEach(function (item) {
                            if (!BackgroundProxy.Recorder.requests[i].request.headers[item.name])
                                BackgroundProxy.Recorder.requests[i].request.headers[item.name] = item.value;
                        });

                        bgRequestsArr.splice(n, 1);
                        break;
                    }
                }
                if (!BackgroundProxy.Recorder.requests[i].request.headers['Host'])
                    BackgroundProxy.Recorder.requests[i].request.headers['Host'] = hostname;

                var resultObj = { hostname: hostname };
                requestHeaders = Object.keys(obj.request.headers).map(name => ({ name, value: obj.request.headers[name] }));
                requestHeaders.find(function (item) {
                    if (item.name.toLowerCase() == 'cookie' && previousValue[hostname].cookie != item.value) {
                        resultObj.browser = { cookie: { item: {} } };
                        resultObj.browser.cookie = { item: item, request: obj };
                        previousValue[hostname].cookie = item.value;
                    }
                    if (item.name.toLowerCase() == 'authorization' && previousValue[hostname].authorization != item.value) {
                        resultObj.browser = { authorization: { item: {} } };
                        resultObj.browser.authorization = { item: item, request: obj };
                        previousValue[hostname].authorization = item.value;
                    }
                });

                responseHeaders = obj.response.headers ?
                    Object.keys(obj.response.headers).map(name => ({ name, value: obj.response.headers[name] })) : [];
                responseHeaders.find(function (item) {
                    if (item.name.toLowerCase() == 'set-cookie') {
                        resultObj.server = { cookie: { item: {} } };
                        resultObj.server.cookie = { item: item, request: obj };
                    }
                });

                if (obj.responseBody && obj.responseBody.body) {
                    var body = obj.responseBody.base64Encoded ? atob(obj.responseBody.body) : obj.responseBody.body,
                        token = body.match(new RegExp('(?:"[^"]*token"\s?:\s?){1}"([A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*)"{1}'));
                    if (token) {
                        resultObj.server = { token: { item: {} } };
                        resultObj.server.token = { item: token[token.length - 1], request: obj };
                    }
                }
                if (resultObj.browser || resultObj.server) {
                    result[i] = resultObj;
                }
            }
        } catch (e) {
            console.log(e)
            BackgroundProxy.Logger.log("Traffic analysis", e);
        }
        return result;
    };
};//end Recorder