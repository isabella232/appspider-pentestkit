/* Author: Denis Podgurskii */
'use strict';

var filter_types = ["main_frame", "sub_frame", "stylesheet", "script", "image", "font", "object", "xmlhttprequest", "ping", "csp_report", "media", "websocket", "other"];
var contexts = ["browser_action", "page", "selection", "link"];


////////////////////////////////////
/* Proxy for all background scripts */
////////////////////////////////////
var BackgroundProxy = {

    excludedTabs: new Array(),

    tabs: [],
    //plugins: ["analyzer", "macro", "request"],
    detector: "assets/js/detector.js",
    dictionary: "assets/js/dictionary.js",

    _settings: null,
    _activeTab: null,
    _previousTab: null,

    avtivePlugin: null,

    pentestkitRequest: { cookie: "", headers: new Map() },

    ////////////////////////////////////
    setTab: function (tabId, params, type) {
        if (type != 'clientApps') {
            //check tabs capturing activated
            if (!this.BrowserActions.isTabsCapturingActive) return;
            //Do nothing for excluded tabs
            if (tabId in this.excludedTabs) return;
            //Listen only active tab
            if (this.activeTab == null || tabId != this.activeTab.tabId) return;
            //do not add chrome extnsions
            if (typeof params.url != 'undefined' && (params.url.startsWith("chrome-extension://") || params.url.startsWith("chrome-extensions://"))) return;
        }
        try {
            if (tabId in this.tabs && this.tabs[tabId] instanceof Tab) {
                this.tabs[tabId].setParams(params, type);
                BackgroundProxy.Logger.log("Update tab ", { tabId: tabId });
            } else {
                this.tabs[tabId] = new Tab(tabId, params, type);
                BackgroundProxy.Logger.log("Add tab ", { tabId: tabId });
            }
            this.tabs[tabId].reduceSize(this.settings.main.general.max_requests_per_tab);
            chrome.runtime.sendMessage({
                channel: "ptkBackgroundToPopup",
                type: "requests source resized"
            });
        } catch (e) {
            BackgroundProxy.Logger.log("Error:", e);
        }
    },

    getTab: function (tabId) {
        if (tabId in this.tabs && this.tabs[tabId] instanceof Tab) {
            return this.tabs[tabId];
        }
        return null;
    },

    excludeTab: function (tabId) {
        if (this._activeTab != null && tabId == this._activeTab.tabId) this._activeTab = this._previousTab;
        if (tabId in this.excludedTabs) return;
        this.excludedTabs[tabId] = tabId;
    },

    clearTab: function (tabId) {
        delete this.tabs[tabId];
    },

    exportTraffic: function (tabId) {
        if (this.tabs[tabId]) {

        }
    },

    set activeTab(s) {
        if (s.tabId in this.excludedTabs) return;
        this._previousTab = this._activeTab;
        this._activeTab = s;
        chrome.runtime.sendMessage({
            channel: "ptkBackgroundToPopup",
            type: "active tab changed"
        });
    },
    get activeTab() {
        return this._activeTab;
    },

    ////////////////////////////////////
    set settings(s) {
        this._settings = s;
    },
    get settings() {
        return this._settings;
    },
    updateSettings(path, value) {
        this._settings = this.Utils.jsonSetValueByPath(this._settings, path, value);
        chrome.storage.local.set({ "pentestkit_settings": this._settings });
    },
    resetSettings: function () {
        this._settings = new Settings();
        chrome.storage.local.set({ "pentestkit_settings": this._settings });
    },

    Request: new Request(),
    Utils: new Utils(),
    Logger: new Logger(),
    eXHeaders: new eXHeaders(),
    Recorder: new Recorder(),
    ////////////////////////////////////
    /* Browser Actions */
    ////////////////////////////////////
    BrowserActions: {

        isTabsCapturingActive: true,
        isHeadersControlActive: false,
        isTrafficRecordingActive: false,
        isMacroRecordingActive: false,

        activateTabsCapturing: function (info, tab) {
            BackgroundProxy.BrowserActions.isTabsCapturingActive = true;
            //chrome.contextMenus.update('activateTabsCapturing', { "title": "Deactivate Tabs Capturing", "onclick": BackgroundProxy.BrowserActions.deactivateTabsCapturing });
        },

        deactivateTabsCapturing: function (info, tab) {
            BackgroundProxy.BrowserActions.isTabsCapturingActive = false;
            //chrome.contextMenus.update('activateTabsCapturing', { "title": "Activate Tabs Capturing", "onclick": BackgroundProxy.BrowserActions.activateTabsCapturing });
        },

        activateHeadersControl: function (info, tab) {
            BackgroundProxy.BrowserActions.isHeadersControlActive = true;
            //chrome.contextMenus.update('activateHeadersControl', { "title": "Deactivate Headers Control", "onclick": BackgroundProxy.BrowserActions.deactivateHeadersControl });
        },

        deactivateHeadersControl: function (info, tab) {
            BackgroundProxy.BrowserActions.isHeadersControlActive = false;
            //chrome.contextMenus.update('activateHeadersControl', { "title": "Activate Headers Control", "onclick": BackgroundProxy.BrowserActions.activateHeadersControl });
        },

        openInNewWindow: function (info, tab) {
            chrome.windows.create({ url: chrome.extension.getURL("browser/index.html"), type: "popup" },
                function (win) {
                    BackgroundProxy.excludeTab(win.tabs[0].id);
                });
        }

    }, //end Browser Actions

}; //end BackgroundProxy



////////////////////////////////////
/* Chrome runtime events handlers */
////////////////////////////////////

chrome.runtime.onInstalled.addListener(function () {
    var settings = new Settings();
    chrome.storage.local.set({ "pentestkit_settings": settings }, function () {
        BackgroundProxy.settings = settings;
    });
    chrome.storage.local.get('pentestkit_headers', function (result) {
        if (result.pentestkit_headers) {
            BackgroundProxy.eXHeaders.headers = result.pentestkit_headers;
        }
    });
    BackgroundProxy.Logger.log("onInstalled", "");
});



///////////////////////////////////
/*  Chrome tabs events handlers  */
///////////////////////////////////
chrome.tabs.onActivated.addListener(function (info) {
    BackgroundProxy.Logger.log("onActivated", { tabId: info.tabId, window: info.windowId, info: info });
    BackgroundProxy.activeTab = { tabId: info.tabId, window: info.windowId };
});


//////////// Macro recording ////////////
chrome.tabs.onUpdated.addListener(function (tabId, info, tab) {
    if (info.status != "complete") return;
    setTimeout(function () {
        if (tab.id == BackgroundProxy.Recorder.tabId) {
            chrome.tabs.executeScript(BackgroundProxy.Recorder.tabId, { file: BackgroundProxy.Recorder.recorderJS, allFrames: true, matchAboutBlank: true }, function (result) {
                BackgroundProxy.Recorder.updateTab(null);
            });
        }
    }, 100);
});

chrome.tabs.onRemoved.addListener(function (tabId, removeInfo) {
    if (tabId == BackgroundProxy.Recorder.tabId) {
        BackgroundProxy.Recorder.stop(removeInfo);
    }
});


/////////////////////////////////////////
/*  Chrome webRequest events handlers  */
/////////////////////////////////////////
chrome.webRequest.onBeforeRequest.addListener(function (request) {
    //if (request.type == 'main_frame') BackgroundProxy.clearTab(request.tabId);
    BackgroundProxy.Logger.log("onBeforeRequest", { tabId: request.tabId, request: request.requestId, request: request });
    BackgroundProxy.setTab(request.tabId, request, 'start');
}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["blocking", "requestBody"]);

////////////////////////////////
chrome.webRequest.onBeforeSendHeaders.addListener(function (request) {
    for (var i in BackgroundProxy.eXHeaders.headers.request) {
        var row = BackgroundProxy.eXHeaders.headers.request[i];
        if (row.type == 'add') {
            //console.log('add');
            request.requestHeaders.push({ name: row.header_name, value: row.header_value });
        }
    }
    //Request from PTK request builder
    let x_ptkHeader = request.requestHeaders.find(obj => { return obj.name == "X-PenetrationTestingKit" });
    if (x_ptkHeader) {
        let jsonHeaders = JSON.parse(atob(x_ptkHeader.value));
        BackgroundProxy.pentestkitRequest.headers.set(request.requestId, []);
        if (BackgroundProxy.pentestkitRequest.cookie != "") {
            jsonHeaders.push({ name: "Cookie", value: BackgroundProxy.pentestkitRequest.cookie });
        }
        return { requestHeaders: jsonHeaders };
    }
    return { requestHeaders: request.requestHeaders };

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["blocking", "requestHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onSendHeaders.addListener(function (request) {
    //console.log(request.requestHeaders);
    BackgroundProxy.Logger.log("onSendHeaders", { tabId: request.tabId, request: request.requestId, request: request });
    BackgroundProxy.setTab(request.tabId, request, 'request');

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["requestHeaders"]);

////////////////////////////////
chrome.webRequest.onHeadersReceived.addListener(function (response) {
    if (BackgroundProxy.pentestkitRequest.headers.has(response.requestId)) {
        BackgroundProxy.pentestkitRequest.cookie = response.responseHeaders.filter(x => x.name.toLowerCase() == 'set-cookie').map(x => x.value).join(";");
        response.responseHeaders.unshift({ name: "", value: response.statusLine });
        BackgroundProxy.pentestkitRequest.headers.set(response.requestId, response.responseHeaders);
    }
    //response.responseHeaders.push({ "name": "Access-Control-Allow-Origin", "value": "*" });
    return { responseHeaders: response.responseHeaders };
}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["blocking", "responseHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onBeforeRedirect.addListener(function (response) {
    BackgroundProxy.Logger.log("onBeforeRedirect", { tabId: response.tabId, request: response.requestId, response: response });
    BackgroundProxy.setTab(response.tabId, response, 'redirect');
}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["responseHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onResponseStarted.addListener(function (response) {

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["responseHeaders"]);

////////////////////////////////
chrome.webRequest.onCompleted.addListener(function (response) {
    BackgroundProxy.Logger.log("onCompleted", { tabId: response.tabId, request: response.requestId, response: response });
    BackgroundProxy.setTab(response.tabId, response, 'response');

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["responseHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onErrorOccurred.addListener(function (details) {
    // console.error(details.error);
}, {
        urls: ["<all_urls>"],
        types: filter_types
    });


// AppSpider functionality
chrome.runtime.onMessage.addListener(
    function (message, sender, sendResponse) {
        if (message && message.channel == 'pentestkitAppSpiderChannel') {
            if (message.function == 'validate')
                BackgroundProxy.Request.validate(message);
            if (message.function == 'setPlugin' && message.parameters.plugin)
                BackgroundProxy.avtivePlugin = message.parameters.plugin;

        }
    });