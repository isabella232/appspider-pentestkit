/* Author: Denis Podgurskii */
'use strict';

var filter_types = ["main_frame", "sub_frame", "stylesheet", "script", "image", "font", "object", "xmlhttprequest", "ping", "csp_report", "media", "websocket", "other"];
var contexts = ["browser_action", "page", "selection", "link"];


////////////////////////////////////
/* Proxy for all background scripts */
////////////////////////////////////
var BackgroundProxy = {

    excludedTabs: new Array(),

    tabs: [],
    //plugins: ["analyzer", "macro", "request"],
    detector: "assets/js/detector.js",
    dictionary: "assets/js/dictionary.js",

    _settings: new Settings(),
    _activeTab: null,
    _previousTab: null,

    activePlugin: null,

    pentestkitRequest: { cookie: {}, statusLine: "", headers: new Map() },

    ////////////////////////////////////
    setTab: function (tabId, params, type) {
        if (type != 'clientApps') {
            //check tabs capturing activated
            if (!this.BrowserActions.isTabsCapturingActive) return;
            //Do nothing for excluded tabs
            if (tabId in this.excludedTabs) return;
            //Listen only active tab
            if (this.activeTab == null || tabId != this.activeTab.tabId) return;
            //do not add chrome extnsions
            if (typeof params.url != 'undefined' && (params.url.startsWith("chrome-extension://") || params.url.startsWith("chrome-extensions://"))) return;
        }
        try {
            if (tabId in this.tabs && this.tabs[tabId] instanceof Tab) {
                this.tabs[tabId].setParams(params, type);
                BackgroundProxy.Logger.log("Update tab ", { tabId: tabId });
            } else {
                this.tabs[tabId] = new Tab(tabId, params, type);
                BackgroundProxy.Logger.log("Add tab ", { tabId: tabId });
            }
            this.tabs[tabId].reduceSize(this.settings.main.general.max_requests_per_tab);
            chrome.runtime.sendMessage({
                channel: "ptkBackgroundToPopup",
                type: "requests source resized"
            });
        } catch (e) {
            BackgroundProxy.Logger.log("Error:", e);
        }
    },

    getTab: function (tabId) {
        if (tabId in this.tabs && this.tabs[tabId] instanceof Tab) {
            return this.tabs[tabId];
        }
        return null;
    },

    excludeTab: function (tabId) {
        if (this._activeTab != null && tabId == this._activeTab.tabId) this._activeTab = this._previousTab;
        if (tabId in this.excludedTabs) return;
        this.excludedTabs[tabId] = tabId;
    },

    clearTab: function (tabId) {
        delete this.tabs[tabId];
    },

    // exportTraffic: function (tabId) {
    //     if (this.tabs[tabId]) {

    //     }
    // },


    set activeTab(s) {
        if (s.tabId in this.excludedTabs) return;
        this._previousTab = this._activeTab;
        this._activeTab = s;
        chrome.runtime.sendMessage({
            channel: "ptkBackgroundToPopup",
            type: "active tab changed"
        });
    },
    get activeTab() {
        return this._activeTab;
    },

    ////////////////////////////////////
    set settings(s) {
        this._settings = s;
    },
    get settings() {
        return this._settings;
    },
    updateSettings(path, value) {
        this._settings = this.Utils.jsonSetValueByPath(this._settings, path, value);
        chrome.storage.local.set({ "pentestkit_settings": this._settings });
    },
    resetSettings: function () {
        this._settings = new Settings();
        chrome.storage.local.set({ "pentestkit_settings": this._settings });
    },
    mergeSettings: function (target, ...sources) {
        if (!sources.length) return target;
        const source = sources.shift();
        for (const key in source) {
            if (typeof (source[key]) === 'object') {
                if (!target[key]) Object.assign(target, { [key]: {} });
                this.mergeSettings(target[key], source[key]);
            } else {
                Object.assign(target, { [key]: source[key] });
            }
        }
        return this.mergeSettings(target, ...sources);
    },

    Request: new Request(),
    Utils: new Utils(),
    Logger: new Logger(),
    eXHeaders: new eXHeaders(),
    Recorder: new Recorder(),
    Exporter: new Exporter(),
    ////////////////////////////////////
    /* Browser Actions */
    ////////////////////////////////////
    BrowserActions: {

        isTabsCapturingActive: true,
        isHeadersControlActive: false,
        isTrafficRecordingActive: false,
        isMacroRecordingActive: false,

        activateTabsCapturing: function (info, tab) {
            BackgroundProxy.BrowserActions.isTabsCapturingActive = true;
            //chrome.contextMenus.update('activateTabsCapturing', { "title": "Deactivate Tabs Capturing", "onclick": BackgroundProxy.BrowserActions.deactivateTabsCapturing });
        },

        deactivateTabsCapturing: function (info, tab) {
            BackgroundProxy.BrowserActions.isTabsCapturingActive = false;
            //chrome.contextMenus.update('activateTabsCapturing', { "title": "Activate Tabs Capturing", "onclick": BackgroundProxy.BrowserActions.activateTabsCapturing });
        },

        activateHeadersControl: function (info, tab) {
            BackgroundProxy.BrowserActions.isHeadersControlActive = true;
            //chrome.contextMenus.update('activateHeadersControl', { "title": "Deactivate Headers Control", "onclick": BackgroundProxy.BrowserActions.deactivateHeadersControl });
        },

        deactivateHeadersControl: function (info, tab) {
            BackgroundProxy.BrowserActions.isHeadersControlActive = false;
            //chrome.contextMenus.update('activateHeadersControl', { "title": "Activate Headers Control", "onclick": BackgroundProxy.BrowserActions.activateHeadersControl });
        },

        openInNewWindow: function (info, tab) {
            chrome.windows.create({ url: chrome.extension.getURL("browser/index.html"), type: "popup" },
                function (win) {
                    BackgroundProxy.excludeTab(win.tabs[0].id);
                });
        }

    }, //end Browser Actions

}; //end BackgroundProxy



////////////////////////////////////
/* Chrome runtime events handlers */
////////////////////////////////////

chrome.runtime.onInstalled.addListener(function () {
    chrome.storage.local.get('pentestkit_headers', function (result) {
        if (result.pentestkit_headers) {
            BackgroundProxy.eXHeaders.headers = result.pentestkit_headers;
        }
    });
    chrome.storage.local.get('pentestkit_settings', function (result) {
        var settings = new Settings();
        if (result.pentestkit_settings) {
            settings = BackgroundProxy.mergeSettings(settings, result.pentestkit_settings);
        }
        chrome.storage.local.set({ "pentestkit_settings": settings }, function () {
            BackgroundProxy.settings = settings;
        });
    });
    BackgroundProxy.Logger.log("onInstalled", "");
});



///////////////////////////////////
/*  Chrome tabs events handlers  */
///////////////////////////////////
chrome.tabs.onActivated.addListener(function (info) {
    BackgroundProxy.Logger.log("onActivated", { tabId: info.tabId, window: info.windowId, info: info });
    BackgroundProxy.activeTab = { tabId: info.tabId, window: info.windowId };
});


//////////// Macro recording ////////////
chrome.tabs.onUpdated.addListener(function (tabId, info, tab) {
    if (info.status != "complete") return;
    setTimeout(function () {
        if (tab.id == BackgroundProxy.Recorder.tabId) {
            if (!tab.url.startsWith("chrome-extension://")) {
                chrome.tabs.executeScript(BackgroundProxy.Recorder.tabId, { file: BackgroundProxy.Recorder.recorderJS, matchAboutBlank: true }, function (result) {
                    BackgroundProxy.Recorder.updateTab(null);
                });
            } else{
                chrome.tabs.sendMessage(BackgroundProxy.Recorder.tabId, {
                    channel: 'ptkBackgroundToRecorder',
                    action: "openRecorderURL",
                    url: BackgroundProxy.Recorder.startUrl
                });  
            }
        }
    }, 10);
});

chrome.tabs.onRemoved.addListener(function (tabId, removeInfo) {
    if (tabId == BackgroundProxy.Recorder.tabId) {
        BackgroundProxy.Recorder.stop(removeInfo);
    }
});


/////////////////////////////////////////
/*  Chrome webRequest events handlers  */
/////////////////////////////////////////
chrome.webRequest.onBeforeRequest.addListener(function (request) {
    //if (request.type == 'main_frame') BackgroundProxy.clearTab(request.tabId);
    BackgroundProxy.Logger.log("onBeforeRequest", { tabId: request.tabId, request: request.requestId, request: request });
    BackgroundProxy.setTab(request.tabId, request, 'start');
}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["blocking", "requestBody"]);

////////////////////////////////
chrome.webRequest.onBeforeSendHeaders.addListener(function (request) {
    for (var i in BackgroundProxy.eXHeaders.headers.request) {
        var row = BackgroundProxy.eXHeaders.headers.request[i];
        if (row.type == 'add') {
            request.requestHeaders.push({ name: row.header_name, value: row.header_value });
        }
    }

    return { requestHeaders: request.requestHeaders };

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["blocking", "requestHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onSendHeaders.addListener(function (request) {
    //Request from PTK request builder
    let x_ptkHeader = request.requestHeaders.find(obj => { return obj.name == "X-PenetrationTestingKit" });
    if (x_ptkHeader) {
        //let x_ptkHeaderIndex = request.requestHeaders.findIndex(obj => { return obj.name == "X-PenetrationTestingKit" });
        let jsonHeaders = JSON.parse(atob(x_ptkHeader.value));
        BackgroundProxy.pentestkitRequest.headers.set(request.requestId, []);
        if (BackgroundProxy.pentestkitRequest.cookie.length > 0) {
            jsonHeaders.push({ name: "Cookie", value: BackgroundProxy.pentestkitRequest.cookie.map(x => x.name + "=" + x.value).join(";") });
        }
        return { requestHeaders: jsonHeaders };
    }
    // No cache
    var cacheControl = request.requestHeaders.find(obj => { return obj.name.toLowerCase() == "cache-control" });
    if (!cacheControl) {
        request.requestHeaders.push({
            "name": "Cache-Control",
            "value": "no-cache"
        });
    }
    //console.log(request.requestHeaders);
    BackgroundProxy.Logger.log("onSendHeaders", { tabId: request.tabId, request: request.requestId, request: request });
    BackgroundProxy.setTab(request.tabId, request, 'request');
    return { requestHeaders: request.requestHeaders };

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["requestHeaders"]);

////////////////////////////////
chrome.webRequest.onHeadersReceived.addListener(function (response) {
    if (BackgroundProxy.pentestkitRequest.headers.has(response.requestId)) {
        BackgroundProxy.pentestkitRequest.cookie = response.responseHeaders.filter(x => x.name.toLowerCase() == 'set-cookie').map(
            x => {
                var parts = x.value.split(";").filter(item => typeof item === "string" && !!item.trim());
                var nameValue = parts.shift().split("=");
                var name = nameValue.shift();
                var value = nameValue.join("=");
                return {
                    name: name,
                    value: value
                };
            }
        );
        BackgroundProxy.pentestkitRequest.statusLine = response.statusLine;
        BackgroundProxy.pentestkitRequest.headers.set(response.requestId, response.responseHeaders);
    }
    return { responseHeaders: response.responseHeaders };
}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["blocking", "responseHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onBeforeRedirect.addListener(function (response) {
    BackgroundProxy.Logger.log("onBeforeRedirect", { tabId: response.tabId, request: response.requestId, response: response });
    BackgroundProxy.setTab(response.tabId, response, 'redirect');
}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["responseHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onResponseStarted.addListener(function (response) {

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["responseHeaders"]);

////////////////////////////////
chrome.webRequest.onCompleted.addListener(function (response) {
    BackgroundProxy.Logger.log("onCompleted", { tabId: response.tabId, request: response.requestId, response: response });
    BackgroundProxy.setTab(response.tabId, response, 'response');

}, {
        urls: ["<all_urls>"],
        types: filter_types
    }, ["responseHeaders", "extraHeaders"]);

////////////////////////////////
chrome.webRequest.onErrorOccurred.addListener(function (details) {
    // console.error(details.error);
}, {
        urls: ["<all_urls>"],
        types: filter_types
    });


// AppSpider functionality
chrome.runtime.onMessage.addListener(
    function (message, sender, sendResponse) {

        //Validate
        if (message.channel == 'pentestkitAppSpiderValidateChannel' && message.function == 'validate') {
            BackgroundProxy.Request.validate(message);
        }

        //Macro / Traffic
        if (message.channel == 'pentestkitAppSpiderRecorderChannel') {
            if (message.function == 'start') {
                BackgroundProxy.Recorder.openerTabId = sender.tab.id;
                BackgroundProxy.Recorder.start(message.parameters);
            }
            if (message.function == 'stop')
                BackgroundProxy.Recorder.stop(null);
        }

        //Bootstrap start
        if (message.channel == 'pentestkitAppSpiderBootstrapChannel') {
            if (message.function == 'start') {
                BackgroundProxy.Recorder.openerTabId = sender.tab.id;
                BackgroundProxy.Recorder.startBootstrap(message.parameters);
            }
        }

        //Recorder
        if (message.channel == 'ptkRecorderToBackground' && message.function == 'append') {
            BackgroundProxy.Recorder.append(message.data);
        }
    });

chrome.runtime.onConnect.addListener(function (port) {

    if (port.name == "pentestkitAppSpiderRecorderPort") {
        port.onMessage.addListener(function (msg) {
            var output = {};
            if (msg.function == 'exportMacro')
                output = BackgroundProxy.Exporter.renderXml(BackgroundProxy.Recorder.items, msg.options);
            if (msg.function == 'exportTraffic') {
                output = msg.useHAR ?
                    BackgroundProxy.Exporter.renderHar(BackgroundProxy.Recorder.requests) :
                    BackgroundProxy.Exporter.renderAppSpiderFormat(BackgroundProxy.Recorder.requests);
            }

            var result = {
                result: output,
                bootstrapJobID: BackgroundProxy.Recorder.bootstrapJobID,
                bootstrapEndpoint: BackgroundProxy.Recorder.bootstrapEndpoint
            };
            port.postMessage(result);
            BackgroundProxy.Recorder.reset();
        });
    }

    //Bootstrap stop and send traffic
    if (port.name == "pentestkitAppSpiderBootstrapPort") {
        port.onMessage.addListener(function (msg) {
            BackgroundProxy.Recorder.stop(null);
            if (msg.function == 'stopListening' && !BackgroundProxy.Recorder.bootstrapUsePut) {
                port.postMessage({});
                return;
            }
            //Send bootstrap traffic
            var output = BackgroundProxy.Recorder.bootstrapUsePut ?
                BackgroundProxy.Exporter.renderHar(BackgroundProxy.Recorder.requests) :
                BackgroundProxy.Exporter.renderAppSpiderFormat(BackgroundProxy.Recorder.requests);

            var result = {
                output: output,
                bootstrapJobID: BackgroundProxy.Recorder.bootstrapJobID,
                bootstrapEndpoint: BackgroundProxy.Recorder.bootstrapEndpoint,
                bootstrapPutParams: BackgroundProxy.Recorder.bootstrapPutParams,
                bootstrapUsePut: BackgroundProxy.Recorder.bootstrapUsePut
            };
            port.postMessage(result);
            BackgroundProxy.Recorder.reset();
        });
    }
});