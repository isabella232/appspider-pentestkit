/* Author: Denis Podgurskii */
'use strict';

var filter_types = ["main_frame", "sub_frame", "stylesheet", "script", "image", "font", "object", "xmlhttprequest", "ping", "csp_report", "media", "websocket", "other"];
var contexts = ["browser_action", "page", "selection", "link"];

var isFirefox = browser.runtime.getBrowserInfo ? true : false;
var extraHeaders = isFirefox ? [] : ["extraHeaders"];



////////////////////////////////////
/* Proxy for all background scripts */
////////////////////////////////////
var BackgroundProxy = {

    excludedTabs: new Array(),

    tabs: [],
    //plugins: ["analyzer", "macro", "request"],
    detector: "assets/js/content/detector.js",
    dictionary: "assets/js/content/dictionary.js",

    _settings: new Settings(),
    _activeTab: null,
    _previousTab: null,
    isFirefox: isFirefox,
    activePlugin: null,


    pentestkitRequest: { cookie: {}, statusLine: "", headers: new Map() },

    ////////////////////////////////////
    setTab: function (tabId, params, type) {
        if (type != 'clientApps') {
            //check tabs capturing activated
            if (!this.BrowserActions.isTabsCapturingActive) return;
            //Do nothing for excluded tabs
            if (tabId in this.excludedTabs) return;
            //Listen only active tab
            if (this.activeTab == null || tabId != this.activeTab.tabId) return;
            //do not add chrome extensions
            if (typeof params.url != 'undefined' && (params.url.includes("-extension://") || params.url.includes("-extensions://"))) return;
        }
        try {
            if (tabId in this.tabs && this.tabs[tabId] instanceof Tab) {
                this.tabs[tabId].setParams(params, type);
                BackgroundProxy.Logger.log("Update tab ", { tabId: tabId });
            } else {
                this.tabs[tabId] = new Tab(tabId, params, type);
                this.reduceTabs(this.settings.main.general.max_tabs, tabId);
                BackgroundProxy.Logger.log("Add tab ", { tabId: tabId });
            }
            this.tabs[tabId].reduceTabSize(this.settings.main.general.max_requests_per_tab);
            browser.runtime.sendMessage({
                channel: "ptkBackgroundToPopup",
                type: "requests source resized"
            }).catch(e => e);;
        } catch (e) {
            console.log(e)
            BackgroundProxy.Logger.log("Error:", e);
        }
    },

    getTab: function (tabId) {
        if (tabId in this.tabs && this.tabs[tabId] instanceof Tab) {
            return this.tabs[tabId];
        }
        return null;
    },

    excludeTab: function (tabId) {
        if (this._activeTab != null && tabId == this._activeTab.tabId) this._activeTab = this._previousTab;
        if (tabId in this.excludedTabs) return;
        this.excludedTabs[tabId] = tabId;
    },

    clearTab: function (tabId) {
        delete this.tabs[tabId];
    },

    reduceTabs: function (maxTabs, newTabId) {
        let tabsCount = Object.keys(this.tabs).length;
        if (tabsCount <= maxTabs) return;
        let removeKey = []; let count = 0;
        this.tabs.forEach((tab, key) => {
            if ((tabsCount - count) > maxTabs && key != newTabId) {
                removeKey.push(key);
                count++;
            }
        });
        if (removeKey.length > 0) {
            removeKey.forEach((tabId) => {
                delete BackgroundProxy.tabs[tabId];
            });
        }
    },

    set activeTab(s) {
        if (s.tabId in this.excludedTabs) return;
        this._previousTab = this._activeTab;
        this._activeTab = s;
        browser.runtime.sendMessage({
            channel: "ptkBackgroundToPopup",
            type: "active tab changed"
        }).catch(e => e);;
    },
    get activeTab() {
        return this._activeTab;
    },

    ////////////////////////////////////
    set settings(s) {
        this._settings = s;
    },
    get settings() {
        return this._settings;
    },
    updateSettings(path, value) {
        this._settings = this.Utils.jsonSetValueByPath(this._settings, path, value);
        browser.storage.local.set({ "pentestkit_settings": this._settings });
    },
    resetSettings: function () {
        this._settings = new Settings();
        browser.storage.local.set({ "pentestkit_settings": this._settings });
    },
    mergeSettings: function (target, ...sources) {
        if (!sources.length) return target;
        const source = sources.shift();
        for (const key in source) {
            if (typeof (source[key]) === 'object') {
                if (!target[key]) Object.assign(target, { [key]: {} });
                this.mergeSettings(target[key], source[key]);
            } else {
                Object.assign(target, { [key]: source[key] });
            }
        }
        return this.mergeSettings(target, ...sources);
    },

    Request: new ptkRequest(),
    Utils: new Utils(),
    Logger: new Logger(),
    eXHeaders: new eXHeaders(),
    Recorder: new Recorder(),
    Exporter: new Exporter(),
    Notifications: new Notifications(),
    Scan: new Scan(),
    ////////////////////////////////////
    /* Browser Actions */
    ////////////////////////////////////
    BrowserActions: {

        isTabsCapturingActive: true,
        isHeadersControlActive: false,
        isTrafficRecordingActive: false,
        isMacroRecordingActive: false,

        activateTabsCapturing: function (info, tab) {
            BackgroundProxy.BrowserActions.isTabsCapturingActive = true;
            //browser.contextMenus.update('activateTabsCapturing', { "title": "Deactivate Tabs Capturing", "onclick": BackgroundProxy.BrowserActions.deactivateTabsCapturing });
        },

        deactivateTabsCapturing: function (info, tab) {
            BackgroundProxy.BrowserActions.isTabsCapturingActive = false;
            //browser.contextMenus.update('activateTabsCapturing', { "title": "Activate Tabs Capturing", "onclick": BackgroundProxy.BrowserActions.activateTabsCapturing });
        },

        activateHeadersControl: function (info, tab) {
            BackgroundProxy.BrowserActions.isHeadersControlActive = true;
            //browser.contextMenus.update('activateHeadersControl', { "title": "Deactivate Headers Control", "onclick": BackgroundProxy.BrowserActions.deactivateHeadersControl });
        },

        deactivateHeadersControl: function (info, tab) {
            BackgroundProxy.BrowserActions.isHeadersControlActive = false;
            //browser.contextMenus.update('activateHeadersControl', { "title": "Activate Headers Control", "onclick": BackgroundProxy.BrowserActions.activateHeadersControl });
        },

        openInNewWindow: function (info, tab) {
            browser.windows.create({ url: browser.extension.getURL("browser/index.html"), type: "popup" }).then(
                function (win) {
                    BackgroundProxy.excludeTab(win.tabs[0].id);
                });
        }

    }, //end Browser Actions

}; //end BackgroundProxy



////////////////////////////////////
/* Chrome runtime events handlers */
////////////////////////////////////

browser.runtime.onInstalled.addListener(function () {
    browser.storage.local.get('pentestkit_headers').then(function (result) {
        if (result.pentestkit_headers) {
            BackgroundProxy.eXHeaders.headers = result.pentestkit_headers;
        }
    });
    browser.storage.local.get('pentestkit_settings').then(function (result) {
        var settings = new Settings();
        if (result.pentestkit_settings) {
            settings = BackgroundProxy.mergeSettings(settings, result.pentestkit_settings);
        }
        browser.storage.local.set({ "pentestkit_settings": settings }).then(function () {
            BackgroundProxy.settings = settings;
        });
    });
    BackgroundProxy.Logger.log("onInstalled", "");
});


///////////////////////////////////
/*  Chrome tabs events handlers  */
///////////////////////////////////
browser.tabs.onActivated.addListener(function (info) {
    BackgroundProxy.Logger.log("onActivated", { tabId: info.tabId, window: info.windowId, info: info });
    BackgroundProxy.activeTab = { tabId: info.tabId, window: info.windowId };
});

browser.tabs.onUpdated.addListener(function (tabId, info, tab) {
    if (info.status != "complete") return;
    setTimeout(function () {
        if (tab.id == BackgroundProxy.Recorder.tabId) {
            if (!tab.url.includes("-extension://") && !tab.url.startsWith('about:blank')) {
                browser.webRequest.handlerBehaviorChanged();
                browser.tabs.executeScript(BackgroundProxy.Recorder.tabId, {
                    file: BackgroundProxy.Recorder.recorderMainJS,
                    matchAboutBlank: true,
                    allFrames: false,
                    runAt: "document_end"
                }).then(function (result) { });
            }
        }
    }, 10);
});

browser.tabs.onRemoved.addListener(function (tabId, removeInfo) {
    if (tabId == BackgroundProxy.Recorder.tabId) {
        BackgroundProxy.Recorder.stop(removeInfo);
    }
});




/////////////////////////////////////////
/*  Chrome webRequest events handlers  */
/////////////////////////////////////////
browser.webRequest.onBeforeRequest.addListener(function (request) {
    BackgroundProxy.Logger.log("onBeforeRequest", { tabId: request.tabId, request: request.requestId, request: request });
    BackgroundProxy.setTab(request.tabId, request, 'start');

    if (BackgroundProxy.Recorder.captureNetwork && request.tabId == BackgroundProxy.Recorder.tabId &&
        !request.url.toLowerCase().startsWith('wss')) {

        var item = {
            requestId: request.requestId,
            wallTime: request.timeStamp,
            type: request.type,
            startTime: +new Date,
            request: request,
            requestHeaders: [],
            responseHeaders: [],
            responseBody: { body: "", base64Encoded: false }
        };
        BackgroundProxy.Recorder.recordingRequests.push(item);

        if (isFirefox) {
            let filter = browser.webRequest.filterResponseData(item.requestId);
            let decoder = new TextDecoder("utf-8");

            filter.ondata = event => {
                let str = decoder.decode(event.data, { stream: true });
                filter.write(event.data);
                filter.disconnect();
                var index = BackgroundProxy.Recorder.recordingRequests.slice().reverse().findIndex(i => i.requestId === item.requestId);
                var count = BackgroundProxy.Recorder.recordingRequests.length - 1;
                index = index >= 0 ? count - index : index;
                BackgroundProxy.Recorder.recordingRequests[index].responseBody = { body: str, base64Encoded: false };
            }
        }
    }
}, {
    urls: ["<all_urls>"],
    types: filter_types
}, ["blocking", "requestBody"].concat(extraHeaders));

////////////////////////////////
browser.webRequest.onBeforeSendHeaders.addListener(function (request) {
    //Request from PTK request builder or Scan
    let x_ptkHeader = request.requestHeaders.find(obj => { return obj.name == "x-penetrationtestingkitheaders" });
    if (x_ptkHeader) {
        let jsonHeaders = JSON.parse(atob(x_ptkHeader.value));
        BackgroundProxy.pentestkitRequest.headers.set(request.requestId, []);
        if (BackgroundProxy.pentestkitRequest.cookie.length > 0) {
            if (jsonHeaders.filter(x => x.name == 'Cookie').length > 0) {
                jsonHeaders.filter(x => x.name == 'Cookie')[0].value = jsonHeaders.filter(x => x.name == 'Cookie')[0].value + ";" + BackgroundProxy.pentestkitRequest.cookie.map(x => x.name + "=" + x.value).join(";");
            } else {
                jsonHeaders.push({ name: "Cookie", value: BackgroundProxy.pentestkitRequest.cookie.map(x => x.name + "=" + x.value).join(";") });
            }
        }
        return { requestHeaders: jsonHeaders };
    }

    // for (var i in BackgroundProxy.eXHeaders.headers.request) {
    //     var row = BackgroundProxy.eXHeaders.headers.request[i];
    //     if (row.type == 'add') {
    //         request.requestHeaders.push({ name: row.header_name, value: row.header_value });
    //     }
    // }

    return { requestHeaders: request.requestHeaders };

}, {
    urls: ["<all_urls>"],
    types: filter_types
}, ["blocking", "requestHeaders"].concat(extraHeaders));

////////////////////////////////
browser.webRequest.onSendHeaders.addListener(function (request) {
    // No cache
    var cacheControl = request.requestHeaders.find(obj => { return obj.name.toLowerCase() == "cache-control" });
    if (!cacheControl) {
        request.requestHeaders.push({
            "name": "Cache-Control",
            "value": "no-cache"
        });
    }

    BackgroundProxy.Logger.log("onSendHeaders", { tabId: request.tabId, request: request.requestId, request: request });
    BackgroundProxy.setTab(request.tabId, request, 'request');

    if (BackgroundProxy.Recorder.captureNetwork && request.tabId == BackgroundProxy.Recorder.tabId &&
        !request.url.toLowerCase().startsWith('wss')) {
        var reverseIndex = BackgroundProxy.Recorder.recordingRequests.slice().reverse().findIndex(i => i.requestId === request.requestId);
        var count = BackgroundProxy.Recorder.recordingRequests.length - 1;
        reverseIndex = reverseIndex >= 0 ? count - reverseIndex : reverseIndex;
        BackgroundProxy.Recorder.recordingRequests[reverseIndex].requestHeaders = request.requestHeaders;

    }

    return { requestHeaders: request.requestHeaders };

}, {
    urls: ["<all_urls>"],
    types: filter_types
}, ["requestHeaders"].concat(extraHeaders));

////////////////////////////////
browser.webRequest.onHeadersReceived.addListener(function (response) {
    if (BackgroundProxy.pentestkitRequest.headers.has(response.requestId)) {
        BackgroundProxy.pentestkitRequest.cookie = response.responseHeaders.filter(x => x.name.toLowerCase() == 'set-cookie').map(
            x => {
                var parts = x.value.split(";").filter(item => typeof item === "string" && !!item.trim());
                var nameValue = parts.shift().split("=");
                var name = nameValue.shift();
                var value = nameValue.join("=");
                return {
                    name: name,
                    value: value
                };
            }
        );
        BackgroundProxy.pentestkitRequest.statusLine = response.statusLine;
        BackgroundProxy.pentestkitRequest.headers.set(response.requestId, response.responseHeaders);
    }
    return { responseHeaders: response.responseHeaders };
}, {
    urls: ["<all_urls>"],
    types: filter_types
}, ["blocking", "responseHeaders"].concat(extraHeaders));

////////////////////////////////
browser.webRequest.onBeforeRedirect.addListener(function (response) {
    BackgroundProxy.Logger.log("onBeforeRedirect", { tabId: response.tabId, request: response.requestId, response: response });
    BackgroundProxy.setTab(response.tabId, response, 'redirect');
}, {
    urls: ["<all_urls>"],
    types: filter_types
}, ["responseHeaders"].concat(extraHeaders));

////////////////////////////////
// browser.webRequest.onResponseStarted.addListener(function (response) {

// }, {
//     urls: ["<all_urls>"],
//     types: filter_types
// }, ["responseHeaders"]);

////////////////////////////////
browser.webRequest.onCompleted.addListener(function (response) {
    BackgroundProxy.Logger.log("onCompleted", { tabId: response.tabId, request: response.requestId, response: response });
    BackgroundProxy.setTab(response.tabId, response, 'response');

    if (BackgroundProxy.Recorder.captureNetwork && response.tabId == BackgroundProxy.Recorder.tabId &&
        !response.url.toLowerCase().startsWith('wss')) {
        var reverseIndex = BackgroundProxy.Recorder.recordingRequests.slice().reverse().findIndex(i => i.requestId === response.requestId);
        var count = BackgroundProxy.Recorder.recordingRequests.length - 1;
        reverseIndex = reverseIndex >= 0 ? count - reverseIndex : reverseIndex;
        BackgroundProxy.Recorder.recordingRequests[reverseIndex].responseHeaders = response.responseHeaders;
        BackgroundProxy.Recorder.recordingRequests[reverseIndex].endTime = +new Date;
    }

}, {
    urls: ["<all_urls>"],
    types: filter_types
}, ["responseHeaders"].concat(extraHeaders));

////////////////////////////////
browser.webRequest.onErrorOccurred.addListener(function (details) {
    // console.error(details.error);
}, {
    urls: ["<all_urls>"],
    types: filter_types
});


// AppSpider functionality
browser.runtime.onMessage.addListener(
    function (message, sender, sendResponse) {

        //Validate
        if (message.channel == 'pentestkitAppSpiderValidateChannel' && message.function == 'validate') {
            BackgroundProxy.Request.validate(message);
        }

        //Macro / Traffic
        if (message.channel == 'pentestkitAppSpiderRecorderChannel') {
            if (message.function == 'start') {
                BackgroundProxy.Recorder.openerTabId = sender.tab.id;
                BackgroundProxy.Recorder.start(message.parameters);
            }
            if (message.function == 'stop')
                BackgroundProxy.Recorder.stop(null);
        }

        //Bootstrap start
        if (message.channel == 'pentestkitAppSpiderBootstrapChannel') {
            if (message.function == 'start') {
                BackgroundProxy.Recorder.openerTabId = sender.tab.id;
                BackgroundProxy.Recorder.startBootstrap(message.parameters);
            }
        }

        //Recorder
        if (message.channel == 'ptkRecorderToBackground') {
            if (message.function == 'framesCollection') {
                browser.tabs.executeScript(BackgroundProxy.Recorder.tabId, {
                    code: 'var PTK_framesCollection = ' + JSON.stringify(message.parameters.frames) + ";",
                    matchAboutBlank: true,
                    allFrames: true,
                    runAt: "document_end"
                }).then(function (result) {
                    browser.tabs.executeScript(BackgroundProxy.Recorder.tabId, {
                        file: BackgroundProxy.Recorder.recorderPolyfillJS,
                        matchAboutBlank: true,
                        allFrames: true,
                        runAt: "document_end"
                    }).then(function(result){
                        browser.tabs.executeScript(BackgroundProxy.Recorder.tabId, {
                            file: BackgroundProxy.Recorder.recorderJS,
                            matchAboutBlank: true,
                            allFrames: true,
                            runAt: "document_end"
                        })
                    })
                });
            }
        }
    });

browser.runtime.onConnect.addListener(function (port) {

    if (port.name == "pentestkitAppSpiderRecorderPort") {
        port.onMessage.addListener(function (msg) {
            var output = {};
            if (msg.function == 'exportMacro')
                output = BackgroundProxy.Exporter.renderXml(BackgroundProxy.Recorder.items, msg.options);
            if (msg.function == 'exportTraffic') {
                BackgroundProxy.Recorder.analyze();
                output = msg.useHAR ?
                    BackgroundProxy.Exporter.renderHar(BackgroundProxy.Recorder.recordingRequests) :
                    BackgroundProxy.Exporter.renderAppSpiderFormat(BackgroundProxy.Recorder.recordingRequests);
            }

            var result = {
                result: output,
                bootstrapJobID: BackgroundProxy.Recorder.bootstrapJobID,
                bootstrapEndpoint: BackgroundProxy.Recorder.bootstrapEndpoint
            };
            port.postMessage(result);
            BackgroundProxy.Recorder.reset();
        });
    }

    //Bootstrap stop and send traffic
    if (port.name == "pentestkitAppSpiderBootstrapPort") {
        port.onMessage.addListener(function (msg) {
            BackgroundProxy.Recorder.stop(null);
            if (msg.function == 'stopListening' && !BackgroundProxy.Recorder.bootstrapUsePut) {
                port.postMessage({});
                return;
            }
            //Send bootstrap traffic
            BackgroundProxy.Recorder.analyze();
            var output = BackgroundProxy.Recorder.bootstrapUsePut ?
                BackgroundProxy.Exporter.renderHar(BackgroundProxy.Recorder.recordingRequests) :
                BackgroundProxy.Exporter.renderAppSpiderFormat(BackgroundProxy.Recorder.recordingRequests);

            var result = {
                output: output,
                bootstrapJobID: BackgroundProxy.Recorder.bootstrapJobID,
                bootstrapEndpoint: BackgroundProxy.Recorder.bootstrapEndpoint,
                bootstrapPutParams: BackgroundProxy.Recorder.bootstrapPutParams,
                bootstrapUsePut: BackgroundProxy.Recorder.bootstrapUsePut
            };
            port.postMessage(result);
            BackgroundProxy.Recorder.reset();
        });
    }
});